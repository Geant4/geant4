// This code implementation is the intellectual property of
// the RD44 GEANT4 collaboration.
//
// By copying, distributing or modifying the Program (or any work
// based on the Program) you indicate your acceptance of this statement,
// and all its terms.
//
// $Id: G4QHadron.cc,v 1.8 2000-09-21 06:51:58 mkossov Exp $
// GEANT4 tag $Name: not supported by cvs2svn $
//
// -----------------------------------------------------------------
//      GEANT 4 class implementation file
//
//      For information related to this code contact:
//      CERN, CN Division, ASD group
//      ---------------- G4QHadron ----------------
//             by Mikhail Kossov, Sept 1999.
//      class for Quasmon initiated Hadrons generated by CHIPS Model
// ------------------------------------------------------------------

//#define debug
//#define pdebug
//#define sdebug

#include "G4QHadron.hh"

G4QHadron::G4QHadron() :
  theQPDG(0),theMomentum(0.,0.,0.,0.),valQ(0,0,0,0,0,0),nFragm(0)
{};

G4QHadron::G4QHadron(G4LorentzVector p) :
  theQPDG(0),theMomentum(p),valQ(0,0,0,0,0,0),nFragm(0)
{};

// For Chipolino or Quasmon doesn't make any sense
G4QHadron::G4QHadron(G4int PDGCode, G4LorentzVector p) :
  theQPDG(PDGCode),theMomentum(p),nFragm(0)
{
  if(GetQCode()>-1)
  {
    if(theMomentum.e()==0.) theMomentum.setE(theQPDG.GetMass());
    valQ=theQPDG.GetQuarkContent();
  }
  else if(PDGCode>80000000) DefineQC(PDGCode);
  else cerr<<"***G4QHaron:(P) PDG="<<PDGCode<<", use other constructor"<<endl;
};

// For Chipolino or Quasmon doesn't make any sense
G4QHadron::G4QHadron(G4QPDGCode QPDG, G4LorentzVector p) :
  theQPDG(QPDG),theMomentum(p),nFragm(0)
{
  if(theQPDG.GetQCode()>-1)
  {
    if(theMomentum.e()==0.) theMomentum.setE(theQPDG.GetMass());
    valQ=theQPDG.GetQuarkContent();
  }
  else
  {
    G4cerr<<"***G4QHaron:(QP) PDG="<<theQPDG.GetPDGCode()<<", use other constructor"<<G4endl;
#ifdef sdebug
	G4Exception("***G4QHadron: QPDG Constructor failed");
#endif
  }

};

// Make sense Chipolino or Quasmon
G4QHadron::G4QHadron(G4QContent QC, G4LorentzVector p) :
  valQ(QC),theMomentum(p),nFragm(0)
{
  G4int curPDG=valQ.GetSPDGCode();
  if(curPDG&&curPDG!=10) theQPDG.SetPDGCode(curPDG);
};

G4QHadron::G4QHadron(G4int PDGCode, G4double aMass, G4QContent QC) :
  theQPDG(PDGCode),theMomentum(0.,0.,0., aMass),valQ(QC),nFragm(0)
{};

G4QHadron::G4QHadron(G4QPDGCode QPDG, G4double aMass, G4QContent QC) :
  theQPDG(QPDG),theMomentum(0.,0.,0., aMass),valQ(QC),nFragm(0)
{};

G4QHadron::G4QHadron(G4int PDGCode, G4LorentzVector p, G4QContent QC) :
  theQPDG(PDGCode),theMomentum(p),valQ(QC),nFragm(0)
{};

G4QHadron::G4QHadron(G4QPDGCode QPDG, G4LorentzVector p, G4QContent QC) :
  theQPDG(QPDG),theMomentum(p),valQ(QC),nFragm(0)
{};

G4QHadron::G4QHadron(G4QParticle* pPart, G4double maxM) :
  theMomentum(0.,0.,0.,0.),nFragm(0),theQPDG(pPart->GetQPDG())
{
#ifdef debug
  cout<<"G4QHadron is created & randomized with maxM="<<maxM<<endl;
#endif
  G4int PDGCode = theQPDG.GetPDGCode();
  if(PDGCode<2) cerr<<"***G4QHaron:(M) PDGC="<<PDGCode<<", use other constructor"<<endl;
  valQ=theQPDG.GetQuarkContent();
  theMomentum.setE(RandomizeMass(pPart, maxM));
}

G4QHadron::G4QHadron(const G4QHadron& right)
{
  theMomentum         = right.theMomentum;
  theQPDG             = right.theQPDG;
  valQ                = right.valQ;
  nFragm              = right.nFragm;
}

G4QHadron::G4QHadron(G4QHadron* right)
{
  theMomentum         = right->theMomentum;
  theQPDG             = right->theQPDG;
  valQ                = right->valQ;
  nFragm              = right->nFragm;
}

const G4QHadron& G4QHadron::operator=(const G4QHadron &right)
{
  theMomentum         = right.theMomentum;
  theQPDG             = right.theQPDG;
  valQ                = right.valQ;
  nFragm              = right.nFragm;

  return *this;
}

G4QHadron::~G4QHadron() {}

// Decay of the Hadron in 2 particles (f + s) in respect to the direction of refference particle
G4bool G4QHadron::RelDecayIn2(G4LorentzVector& f4Mom, G4LorentzVector& s4Mom,
       G4LorentzVector& dir, G4double maxCost, G4double minCost)
{//    ===================================================================
  G4double fM2 = f4Mom.m2();
  G4double fM  = sqrt(fM2);                // Mass of the 1st Hadron
  G4double sM2 = s4Mom.m2();
  G4double sM  = sqrt(sM2);                // Mass of the 2nd Hadron
  G4double iM2 = theMomentum.m2();
  G4double iM  = sqrt(iM2);                // Mass of the decaying hadron
  G4ThreeVector ltb = theMomentum.boostVector(); // Boost vector for backward Lorentz Trans.
  G4ThreeVector ltf = -ltb;                      // Boost vector for forward Lorentz Trans.
  G4LorentzVector cdir = dir;              // A copy to make a transformation to CMS
  cdir.boost(ltf);                         // Direction transpormed to CMS of the Momentum
  G4ThreeVector vdir = cdir.vect();        // 3-Vector of the direction-particle
#ifdef debug
  cout<<"G4QHadron::RelDecayIn2: dir="<<dir<<",ltf="<<ltf<<",cdir="<<cdir<<",vdir="<<vdir<<endl;
#endif
  G4ThreeVector vx(0.,0.,1.);              // Ort in the direction of the reference particle
  G4ThreeVector vy(0.,1.,0.);              // First ort orthogonal to the direction
  G4ThreeVector vz(1.,0.,0.);              // Second ort orthoganal to the direction
  if(vdir.mag2() > 0.)                     // the refference particle isn't at rest in CMS
  {
    vx = vdir.unit();                      // Ort in the direction of the reference particle
    G4ThreeVector vv= vx.orthogonal();     // Not normed orthogonal vector (!)
    vy = vv.unit();                        // First ort orthogonal to the direction
    vz = vx.cross(vy);                     // Second ort orthoganal to the direction
  }
#ifdef debug
  cout<<"G4QHadron::RelDecayIn2:iM="<<iM<<" => fM="<<fM<<" + sM="<<sM<<",ob="<<vx<<vy<<vz<<endl;
#endif
  if(maxCost>1.) maxCost=1.;
  if (abs(iM-fM-sM)<.001)
  {
    G4double fR=fM/iM;
    G4double sR=sM/iM;
    f4Mom=fR*theMomentum;
    s4Mom=sR*theMomentum;
    return true;
  }
  else if (iM<fM+sM || iM==0. || maxCost<-1.)
  {//@@ Later on make a quark content check for the decay
    G4cerr<<"***G4QHadron::RelDecayIn2:fM="<<fM<<"+sM="<<sM<<">iM="<<iM<<",mC="<<maxCost<<G4endl;
    return false;
  }
  G4double d2 = iM2-fM2-sM2;
  G4double p2 = (d2*d2/4.-fM2*sM2)/iM2;    // Decay momentum(^2) in CMS of Quasmon
  if(p2<0.)
  {
#ifdef debug
    cout<<"***G4QHadr:RelDecIn2:p2="<<p2<<"<0,d2^2="<<d2*d2/4.<<"<4*fM2*sM2="<<4*fM2*sM2<<endl;
#endif
    p2=0.;
  }
  G4double p  = sqrt(p2);
  G4double ct = maxCost;
  if(maxCost>minCost&&minCost>=-1.)
  {
    G4double dcost=maxCost-minCost;
    ct = minCost+dcost*G4UniformRand();
  }
  G4double phi= 360.*deg*G4UniformRand();  // @@ Change 360.*deg to M_TWOPI (?)
  G4double ps = p * sqrt(1.-ct*ct);
  G4ThreeVector pVect=(ps*sin(phi))*vz+(ps*cos(phi))*vy+p*ct*vx;
#ifdef debug
  cout<<"G4QHadron::RelDecayIn2:ct="<<ct<<",p="<<p<<",ps="<<ps<<",ph="<<phi<<",v="<<pVect<<endl;
#endif

  f4Mom.setVect(pVect);
  f4Mom.setE(sqrt(fM2+p2));
  s4Mom.setVect((-1)*pVect);
  s4Mom.setE(sqrt(sM2+p2));
  
#ifdef debug
  cout<<"G4QHadron::RelDecayIn2: p2="<<p2<<",v="<<ltb<<",f4Mom="<<f4Mom<<",s4Mom="<<s4Mom<<endl;
#endif
  f4Mom.boost(ltb);                        // Lor.Trans. of 1st hadron back to LS
  s4Mom.boost(ltb);                        // Lor.Trans. of 2nd hadron back to LS
#ifdef debug
  cout << "G4QHadron::RelDecayIn2: ROOT OUTPUT f4Mom="<<f4Mom<<", s4Mom="<<s4Mom<< endl;
#endif
  return true;
}


// Decay of the Hadron in 2 particles (f + s)
G4bool G4QHadron::DecayIn2(G4LorentzVector& f4Mom, G4LorentzVector& s4Mom)
{//    ===================================================================
  G4double fM  = f4Mom.m();                // Mass of the 1st Hadron
  G4double fM2 = f4Mom.m2();
  G4double sM  = s4Mom.m();                // Mass of the 2nd Hadron
  G4double sM2 = s4Mom.m2();
  G4double iM  = theMomentum.m();          // Mass of the decaying hadron
  G4double iM2 = theMomentum.m2();
#ifdef pdebug
  cout << "G4QHadron::DecayIn2: iM="<<iM<<theMomentum<<" => fM="<<fM<<" + sM="<<sM<< endl;
#endif
  //@@ Later on make a quark content check for the decay
  if (abs(iM-fM-sM)<.001)
  {
    G4double fR=fM/iM;
    G4double sR=sM/iM;
    f4Mom=fR*theMomentum;
    s4Mom=sR*theMomentum;
    return true;
  }
  else if (iM<fM+sM || iM==0.)
  {
    cerr << "***G4QHadron::DecayIn2*** fM="<<fM<<" + sM="<<sM<<" > iM="<<iM<< endl;
    return false;
  }
  G4double d2 = iM2-fM2-sM2;
  G4double p2 = (d2*d2/4.-fM2*sM2)/iM2;    // Decay momentum(^2) in CMS of Quasmon
  if (p2<0.)
  {
#ifdef pdebug
    cerr<<"***G4QHadr::DecayIn2:p2="<<p2<<"<0,d2^2="<<d2*d2/4.<<"<4*fM2*sM2="<<4*fM2*sM2<<endl;
#endif
    p2=0.;
  }
  G4double p  = sqrt(p2);
  G4double ct = 1.-2*G4UniformRand();
#ifdef debug
  cout << "G4QHadron::DecayIn2: ct=" << ct << ", p=" << p << endl;
#endif
  G4double phi= 360.*deg*G4UniformRand();  // @@ Change 360.*deg to M_TWOPI (?)
  G4double ps = p * sqrt(1.-ct*ct);
  G4ThreeVector pVect(ps*sin(phi),ps*cos(phi),p*ct);

  f4Mom.setVect(pVect);
  f4Mom.setE(sqrt(fM2+p2));
  s4Mom.setVect((-1)*pVect);
  s4Mom.setE(sqrt(sM2+p2));
  
  G4ThreeVector ltb = theMomentum.boostVector(); // Boost vector for backward Lor.Trans.
#ifdef pdebug
  cout<<"G4QHadron::DecayIn2: LorTransform v="<<ltb<<", f4Mom="<<f4Mom<<", s4Mom="<<s4Mom<<endl;
#endif
  f4Mom.boost(ltb);                        // Lor.Trans. of 1st hadron back to LS
  s4Mom.boost(ltb);                        // Lor.Trans. of 2nd hadron back to LS
#ifdef pdebug
  cout << "G4QHadron::DecayIn2: ROOT OUTPUT f4Mom="<<f4Mom<<", s4Mom="<<s4Mom<< endl;
#endif
  return true;
}

// Decay of the hadron in 3 particles i=>r+s+t
G4bool G4QHadron::DecayIn3(G4LorentzVector& f4Mom,G4LorentzVector& s4Mom,G4LorentzVector& t4Mom)
{//    =========================================================================================
#ifdef debug
  cout<<"G4QHadron::DecayIn3:"<<theMomentum<<"=>pf="<<f4Mom<<"+ps="<<s4Mom<<"+pt="<<t4Mom<<endl;
#endif
  G4double iM  = theMomentum.m();  // Mass of the decaying hadron
  G4double fM  = f4Mom.m();        // Mass of the 1st hadron
  G4double sM  = s4Mom.m();        // Mass of the 2nd hadron
  G4double tM  = t4Mom.m();        // Mass of the 3rd hadron
  if (iM < fM + sM + tM)
  {
    cerr << "***G4QHadron::DecayIn3: fM="<<fM<<" + sM="<<sM<<" + tM="<<tM<<" > iM="<<iM<< endl;
    return false;
  }
  G4double fM2 = fM*fM;
  G4double sM2 = sM*sM;
  G4double tM2 = tM*tM;
  G4double iM2 = iM*iM;
  G4double m13sBase=(iM-sM)*(iM-sM)-(fM+tM)*(fM+tM);
  G4double m12sMin =(fM+sM)*(fM+sM);
  G4double m12sBase=(iM-tM)*(iM-tM)-m12sMin;
  G4double rR = 0.;
  G4double rnd= 1.;
  G4int    tr = 0;                 //@@ Comment if "cout" below is skiped @@
  G4double m12s = 0.;              // Fake definition before the Loop
  while (rnd > rR)
  {
    m12s = m12sMin + m12sBase*G4UniformRand();
    G4double e1=m12s-fM2-sM2;
    G4double e2=iM2-m12s-tM2;
    G4double four12=4*m12s;
    G4double m13sRange=sqrt((e1*e1-four12*fM2)*(e2*e2-four12*tM2))/m12s;
    rR = m13sRange/m13sBase;
    rnd= G4UniformRand();
#ifdef debug
    cout << "G4QHadron::DecayIn3: try to decay #"<<++tr << ", rR="<<rR << ", rnd="<<rnd << endl;
#endif
  }
  G4double m12 = sqrt(m12s);       // Mass of the H1+H2 system
  G4LorentzVector dh4Mom(0.,0.,0.,m12);
  
  if(!DecayIn2(t4Mom,dh4Mom))
  {
    cerr<<"***G4QHadron::DecayIn3: Exception1"<<endl;
	G4Exception("***G4QHadron::DecayIn3(): DecayIn2 did not succeed");
    return false;
  }
#ifdef debug
  cout << "G4QHadron::DecayIn3: Now the last decay of m12=" << dh4Mom.m() << endl;
#endif
  if(!G4QHadron(dh4Mom).DecayIn2(f4Mom,s4Mom))
  {
    cerr<<"***G4QHadron::DecayIn3: Exception2"<<endl;
	G4Exception("G4QHadron::DecayIn3(): DecayIn2 did not succeed");
    return false;
  }
  return true;
}

// Randomize particle mass taking into account the width
G4double G4QHadron::RandomizeMass(G4QParticle* pPart, G4double maxM)
//       ===========================================================
{
  G4double meanM = theQPDG.GetMass();
  G4double width = theQPDG.GetWidth()/2.;
#ifdef debug
  cout<<"G4QHadron::RandomizeMass: meanM="<<meanM<<", halfWidth="<<width<<endl;
#endif
  if(maxM<meanM-3*width) 
  {
#ifdef debug
    cerr<<"***G4QHadron::RandMass: maxM="<<maxM<<" < meanM="<<meanM<<" - 3*halfW="<<width<<endl;
#endif
    return 0.;
  }
  G4double theMass  = 0.;
  if(width==0.)
  {
#ifdef debug
	if(meanM>maxM) cerr<<"***G4QHadron::RandomizeMass:Stable m="<<meanM<<" > maxM="<<maxM<<endl;
#endif
    return meanM;
    //return 0.;
  }
  else if(width<0.)
  {
	cerr<<"***G4QHadron::RandomizeMass: width="<<width<<"<0, PDGC="<<theQPDG.GetPDGCode()<<endl;
	G4Exception("G4QHadron::RandomizeMass: width of the Hadron < 0");
  }
  G4double minM = pPart->MinMassOfFragm();
  if(minM>maxM)
  {
#ifdef debug
	cerr<<"***G4QHadron::RandomizeMass:for PDG="<<theQPDG.GetPDGCode()<<" minM="<<minM
        <<" > maxM="<<maxM<<endl;
#endif
    return 0.;
  }
  //Now calculate the Breit-Wigner distribution with two cuts
  G4double v1=atan((minM-meanM)/width);
  G4double v2=atan((maxM-meanM)/width);
  G4double dv=v2-v1;
#ifdef debug
  cout<<"G4QHadron::RandomizeMass:Mi="<<minM<<",i="<<v1<<",Ma="<<maxM<<",a="<<v2<<","<<dv<<endl;
#endif
  return meanM+width*tan(v1+dv*G4UniformRand());
}




