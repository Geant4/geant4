// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file tools.license for terms.

#ifndef toolx_GL_gl_functions
#define toolx_GL_gl_functions

#ifndef GL_VERSION_1_1
  #error You have to include OpenGL header(s) before including this file.
#endif

namespace toolx {
namespace GL {

#ifdef TOOLS_USE_GL_VERSION_3_2

class gl_functions {
public:
  gl_functions() {}
  virtual ~gl_functions() {}
protected:
  gl_functions(const gl_functions&) {}
  gl_functions& operator=(const gl_functions&) {return *this;}
public:
  virtual bool initialize() {return true;}
public:
  /*GL_VERSION_1_1*/
  void gl__BindTexture(GLenum target, GLuint texture) {::glBindTexture(target,texture);}
  void gl__BlendFunc(GLenum sfactor, GLenum dfactor) {::glBlendFunc(sfactor,dfactor);}
  void gl__ClearDepth(GLdouble depth) {::glClearDepth(depth);}
  void gl__ClearStencil(GLint s) {::glClearStencil(s);}
  void gl__ClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {::glClearColor(red,green,blue,alpha);}
  void gl__Clear(GLbitfield mask) {::glClear(mask);}

  void gl__DeleteTextures(GLsizei n, const GLuint *textures) {::glDeleteTextures(n,textures);}
  void gl__Disable(GLenum cap) {::glDisable(cap);}
  void gl__DrawArrays(GLenum mode, GLint first, GLsizei count) {::glDrawArrays(mode,first,count);}

  void gl__Enable(GLenum cap) {::glEnable(cap);}
  void gl__FrontFace(GLenum mode) {::glFrontFace(mode);}
  void gl__GenTextures(GLsizei n, GLuint *textures) {::glGenTextures(n,textures);}
  GLenum gl__GetError() {return ::glGetError();}
  void gl__GetIntegerv(GLenum pname, GLint *params) {::glGetIntegerv(pname,params);}
  const GLubyte * gl__GetString(GLenum name) {return ::glGetString(name);}
  GLboolean gl__IsTexture(GLuint texture) {return ::glIsTexture(texture);}
  void gl__LineWidth(GLfloat width) {::glLineWidth(width);}
  void gl__PixelStorei(GLenum pname, GLint param) {::glPixelStorei(pname,param);}
  void gl__PointSize(GLfloat size) {::glPointSize(size);}
  void gl__PolygonOffset(GLfloat factor, GLfloat units) {::glPolygonOffset(factor,units);}
  void gl__ReadBuffer(GLenum mode) {::glReadBuffer(mode);}
  void gl__ReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels) {::glReadPixels(x,y,width,height,format,type,pixels);}
  void gl__TexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {::glTexImage2D(target,level,internalformat,width,height,border,format,type,pixels);}
  void gl__TexParameteriv(GLenum target, GLenum pname, const GLint *params) {::glTexParameteriv(target,pname,params);}
  void gl__TexParameteri(GLenum target, GLenum pname, GLint param) {::glTexParameteri(target,pname,param);}
  void gl__Viewport(GLint x, GLint y, GLsizei width, GLsizei height) {::glViewport(x,y,width,height);}
  void gl__Hint(GLenum target,GLenum mode) {::glHint(target,mode);}
  void gl__DepthFunc(GLenum func) {::glDepthFunc(func);}
  void gl__DepthMask(GLboolean flag) {::glDepthMask(flag);}

  /*GL_VERSION_1_5*/
  void gl__GenBuffers(GLsizei n, GLuint *buffers) {::glGenBuffers(n,buffers);}
  void gl__BindBuffer(GLenum target, GLuint buffer) {::glBindBuffer(target,buffer);}
  void gl__DeleteBuffers(GLsizei n, const GLuint *buffers) {::glDeleteBuffers(n,buffers);}
  void gl__BufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage) {::glBufferData(target,size,data,usage);}
  void gl_EnableVertexAttribArray(GLuint index) {::glEnableVertexAttribArray(index);}
  void gl__DisableVertexAttribArray(GLuint index) {::glDisableVertexAttribArray(index);}
  void gl__EnableVertexAttribArray(GLuint index) {::glEnableVertexAttribArray(index);}
  GLboolean gl__IsBuffer(GLuint buffer) {return ::glIsBuffer(buffer);}

  /*GL_VERSION_2_0*/
  GLuint gl__CreateProgram() {return ::glCreateProgram();}
  void gl__DeleteProgram(GLuint program) {::glDeleteProgram(program);}
  void gl__UseProgram(GLuint program) {::glUseProgram(program);}
  void gl__LinkProgram(GLuint program) {::glLinkProgram(program);}
  void gl__GetProgramiv(GLuint program, GLenum pname, GLint *params) {::glGetProgramiv(program,pname,params);}

  void gl__Uniform1i(GLint location, GLint v0) {::glUniform1i(location,v0);}
  void gl__Uniform1f(GLint location, GLfloat v0) {::glUniform1f(location,v0);}
  void gl__Uniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2) {::glUniform3f(location,v0,v1,v2);}
  void gl__Uniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) {::glUniform4f(location,v0,v1,v2,v3);}
  void gl__UniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) {::glUniformMatrix4fv(location,count,transpose,value);}
  void gl__glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) {::glUniformMatrix4fv(location,count,transpose,value);}
  GLint gl__GetUniformLocation(GLuint program, const GLchar *name) {return ::glGetUniformLocation(program,name);}
  void gl__ShaderSource(GLuint shader, GLsizei count, const GLchar* const *string, const GLint *length) {::glShaderSource(shader,count,string,length);}
  GLboolean gl__IsShader(GLuint shader) {return ::glIsShader(shader);}
  void gl__GetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source) {return ::glGetShaderSource(shader,bufSize,length,source);}
  void gl__GetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog) {::glGetShaderInfoLog(shader,bufSize,length,infoLog);}
  void gl__GetShaderiv(GLuint shader, GLenum pname, GLint *params) {::glGetShaderiv(shader,pname,params);}
  void gl__GetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *obj) {::glGetAttachedShaders(program,maxCount,count,obj);}
  void gl__DetachShader(GLuint program, GLuint shader) {::glDetachShader(program,shader);}
  void gl__DeleteShader(GLuint shader) {::glDeleteShader(shader);}
  GLuint gl__CreateShader(GLenum type) {return ::glCreateShader(type);}
  void gl__CompileShader(GLuint shader) {::glCompileShader(shader);}
  void gl__AttachShader(GLuint program, GLuint shader) {::glAttachShader(program,shader);}

  void gl__VertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer) {::glVertexAttribPointer(index,size,type,normalized,stride,pointer);}
  GLint gl__GetAttribLocation(GLuint program, const GLchar *name) {return ::glGetAttribLocation(program,name);}

  /*GL_VERSION_3_0*/
  void gl__BindVertexArray(GLuint array) {::glBindVertexArray(array);}
  void gl__GenVertexArrays(GLsizei n, GLuint *arrays) {::glGenVertexArrays(n,arrays);}
  void gl__DeleteVertexArrays(GLsizei n, const GLuint *arrays) {::glDeleteVertexArrays(n,arrays);}
  GLboolean gl__IsVertexArray(GLuint array) {return ::glIsVertexArray(array);}

  /*GL_VERSION_3_0*/
  GLenum gl__CheckFramebufferStatus(GLenum target) {return ::glCheckFramebufferStatus(target);}
};

#else //not TOOLS_USE_GL_VERSION_3_2

class gl_functions {
public:
  gl_functions() {}
  virtual ~gl_functions() {}
protected:
  gl_functions(const gl_functions&) {}
  gl_functions& operator=(const gl_functions&) {return *this;}
public:
  virtual bool initialize() {return true;}
public:
  /*GL_VERSION_1_1*/
  void gl__Accum(GLenum op, GLfloat value) {::glAccum(op,value);}
  void gl__Begin(GLenum mode) {::glBegin(mode);}
  void gl__BindTexture(GLenum target, GLuint texture) {::glBindTexture(target,texture);}
  void gl__BlendFunc(GLenum sfactor, GLenum dfactor) {::glBlendFunc(sfactor,dfactor);}
  void gl__ClearDepth(GLdouble depth) {::glClearDepth(depth);}
  void gl__ClearStencil(GLint s) {::glClearStencil(s);}
  void gl__ClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {::glClearColor(red,green,blue,alpha);}
  void gl__Clear(GLbitfield mask) {::glClear(mask);}
  void gl__ClearIndex(GLfloat c) {::glClearIndex(c);}
  void gl__ClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {::glClearAccum(red,green,blue,alpha);}
  void gl__Color4fv(const GLfloat *v) {::glColor4fv(v);}
  void gl__Color4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {::glColor4f(red,green,blue,alpha);}
  void gl__ColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) {::glColorPointer(size,type,stride,pointer);}
  void gl__DeleteTextures(GLsizei n, const GLuint *textures) {::glDeleteTextures(n,textures);}
  void gl__Disable(GLenum cap) {::glDisable(cap);}
  void gl__DisableClientState(GLenum array) {::glDisableClientState(array);}
  void gl__DrawArrays(GLenum mode, GLint first, GLsizei count) {::glDrawArrays(mode,first,count);}
  void gl__Enable(GLenum cap) {::glEnable(cap);}
  void gl__EnableClientState(GLenum array) {::glEnableClientState(array);}
  void gl__End() {::glEnd();}
  void gl__FrontFace(GLenum mode) {::glFrontFace(mode);}
  void gl__GenTextures(GLsizei n, GLuint *textures) {::glGenTextures(n,textures);}
  GLenum gl__GetError() {return ::glGetError();}
  void gl__GetIntegerv(GLenum pname, GLint *params) {::glGetIntegerv(pname,params);}
  void gl__GetLightfv(GLenum light, GLenum pname, GLfloat *params) {::glGetLightfv(light,pname,params);}
  void gl__GetMaterialfv(GLenum face, GLenum pname, GLfloat *params) {::glGetMaterialfv(face,pname,params);}
  const GLubyte * gl__GetString(GLenum name) {return ::glGetString(name);}
  GLboolean gl__IsTexture(GLuint texture) {return ::glIsTexture(texture);}
  void gl__Lightfv(GLenum light, GLenum pname, const GLfloat *params) {::glLightfv(light,pname,params);}
  void gl__Lightf(GLenum light, GLenum pname, GLfloat param) {::glLightf(light,pname,param);}
  void gl__LineWidth(GLfloat width) {::glLineWidth(width);}
  void gl__LoadIdentity() {::glLoadIdentity();}
  void gl__LoadMatrixf(const GLfloat *m) {::glLoadMatrixf(m);}
  void gl__MatrixMode(GLenum mode) {::glMatrixMode(mode);}
  void gl__Normal3fv(const GLfloat *v) {::glNormal3fv(v);}
  void gl__Normal3f(GLfloat nx, GLfloat ny, GLfloat nz) {::glNormal3f(nx,ny,nz);}
  void gl__NormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer) {::glNormalPointer(type,stride,pointer);}
  void gl__PixelStorei(GLenum pname, GLint param) {::glPixelStorei(pname,param);}
  void gl__PointSize(GLfloat size) {::glPointSize(size);}
  void gl__PolygonOffset(GLfloat factor, GLfloat units) {::glPolygonOffset(factor,units);}
  void gl__ReadBuffer(GLenum mode) {::glReadBuffer(mode);}
  void gl__ReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels) {::glReadPixels(x,y,width,height,format,type,pixels);}
  void gl__ShadeModel(GLenum mode) {::glShadeModel(mode);}
  void gl__TexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) {::glTexCoordPointer(size,type,stride,pointer);}
  void gl__TexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {::glTexImage2D(target,level,internalformat,width,height,border,format,type,pixels);}
  void gl__TexParameteriv(GLenum target, GLenum pname, const GLint *params) {::glTexParameteriv(target,pname,params);}
  void gl__TexParameteri(GLenum target, GLenum pname, GLint param) {::glTexParameteri(target,pname,param);}
  void gl__Vertex3fv(const GLfloat *v) {::glVertex3fv(v);}
  void gl__Vertex3f(GLfloat x, GLfloat y, GLfloat z) {::glVertex3f(x,y,z);}
  void gl__VertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) {::glVertexPointer(size,type,stride,pointer);}
  void gl__Viewport(GLint x, GLint y, GLsizei width, GLsizei height) {::glViewport(x,y,width,height);}
  void gl__Hint(GLenum target,GLenum mode) {::glHint(target,mode);}
  void gl__DepthFunc(GLenum func) {::glDepthFunc(func);}
  void gl__DepthMask(GLboolean flag) {::glDepthMask(flag);}

  void gl__NewList(GLuint list, GLenum mode) {::glNewList(list,mode);}
  void gl__DeleteLists(GLuint list, GLsizei range) {::glDeleteLists(list,range);}
  void gl__CallLists(GLsizei n, GLenum type, const GLvoid *lists) {::glCallLists(n,type,lists);}
  void gl__CallList(GLuint list) {::glCallList(list);}
  void gl__EndList() {::glEndList();}
  GLuint gl__GenLists(GLsizei range) {return ::glGenLists(range);}
  GLboolean gl__IsList(GLuint list) {return ::glIsList(list);}

  /*GL_VERSION_3_0*/
#ifdef __APPLE__
#ifdef __COREFOUNDATION__  //Cocoa.h included: we build a Cocoa application.
  GLenum gl__CheckFramebufferStatus(GLenum target) {return ::glCheckFramebufferStatus(target);}
#endif
#endif
};


#endif //not TOOLS_USE_GL_VERSION_3_2

}}

#endif
