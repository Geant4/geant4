//
// ********************************************************************
// * DISCLAIMER                                                       *
// *                                                                  *
// * The following disclaimer summarizes all the specific disclaimers *
// * of contributors to this software. The specific disclaimers,which *
// * govern, are listed with their locations in:                      *
// *   http://cern.ch/geant4/license                                  *
// *                                                                  *
// * Neither the authors of this software system, nor their employing *
// * institutes,nor the agencies providing financial support for this *
// * work  make  any representation or  warranty, express or implied, *
// * regarding  this  software system or assume any liability for its *
// * use.                                                             *
// *                                                                  *
// * This  code  implementation is the  intellectual property  of the *
// * GEANT4 collaboration.                                            *
// * By copying,  distributing  or modifying the Program (or any work *
// * based  on  the Program)  you indicate  your  acceptance of  this *
// * statement, and all its terms.                                    *
// ********************************************************************
//
//
// $Id: G4VSurface.icc,v 1.2 2004/05/28 13:13:35 gcosmo Exp $
// GEANT4 tag $Name: geant4-06-02 $
//
// 
// --------------------------------------------------------------------
// G4VSurface class inline methods
//
// Author: 
//   01-Aug-2002 - Kotoyo Hoshina (hoshina@hepburn.s.chiba-u.ac.jp)
//
// History:
//   13-Nov-2003 - O.Link (Oliver.Link@cern.ch), Integration in Geant4
//                 from original version in Jupiter-2.5.02 application.
// --------------------------------------------------------------------

//=====================================================================
//* DistanceToPlaneWithV ----------------------------------------------

inline
G4double G4VSurface::DistanceToPlaneWithV(const G4ThreeVector &p,
                                          const G4ThreeVector &v,
                                          const G4ThreeVector &x0,
                                          const G4ThreeVector &n0,
                                                G4ThreeVector &xx)
{
   G4double t = (n0 * (x0 - p)) / (n0 * v);
   xx = p + t * v;
   return t;
}

//=====================================================================
//* DistanceToPlane ---------------------------------------------------

inline
G4double G4VSurface::DistanceToPlane(const G4ThreeVector &p,
                                     const G4ThreeVector &x0,
                                     const G4ThreeVector &n0,
                                           G4ThreeVector &xx)
{
   // DistanceToPlane :
   // Calculate distance to plane in local coordinate,
   // then return distance and global intersection points.
   //
   // p          - location of flying particle   
   // x0         - reference point of surface
   // xx         - a foot of perpendicular line from p to the plane 
   // t          - distance from xx to p
   // n          - a unit normal of this plane from plane to p. 
   //
   // equation of plane:
   //      n*(x - x0) = 0;
   //
   // vector to xx:
   //      xx = p - t*n
   //
   //         where
   //         t = n * (p - x0) / abs(n)
   //
   G4double t;
   G4ThreeVector n = n0.unit();
   t = n * (p - x0);
   xx = p - t * n;
   return t;
}

//=====================================================================
//* DistanceToPlane ---------------------------------------------------

inline
G4double G4VSurface::DistanceToPlane(const G4ThreeVector &p,
                                     const G4ThreeVector &x0,
                                     const G4ThreeVector &t1,
                                     const G4ThreeVector &t2,
                                           G4ThreeVector &xx,
                                           G4ThreeVector &n)
{
   // DistanceToPlane :
   // Calculate distance to plane in local coordinate,
   // then return distance and global intersection points.
   // t1         - 1st. vector lying on the plane 
   // t2         - 2nd. vector lying on the plane

   n = (t1.cross(t2)).unit();
   return DistanceToPlane(p, x0, n, xx); 
}

//=====================================================================
//* DistanceToLine ----------------------------------------------------

inline
G4double G4VSurface::DistanceToLine(const G4ThreeVector &p,
                                    const G4ThreeVector &x0,
                                    const G4ThreeVector &d,
                                          G4ThreeVector &xx)
{
   // DistanceToLine :
   // Calculate distance to line,
   // then return distance and global intersection points.
   //
   // p          - location of flying particle   
   // x0         - reference point of line
   // d          - direction vector of line
   // xx         - a foot of perpendicular line from p to the plane 
   // t          - distance from xx to p
   //
   // Equation
   //
   //    distance^2 = |(xx - p)|^2
   //    with
   //       xx = x0 + t*d
   //
   //   (d/dt)distance^2 = (d/dt)|((x0 + t*d) - p)|^2
   //                    = 2*t*|d|^2 + 2*d*(x0 - p)
   //                    = 0  // smallest distance
   //   then
   //      t = - d*(x0 - p) / |d|^2
   //

   G4double t;
   G4ThreeVector dir = d.unit();
   t  = - dir * (x0 - p);      // |dir|^2 = 1.
   xx = x0 + t * dir;
   
   G4ThreeVector dist = xx - p;
   return dist.mag();
}

//=====================================================================
//* IsAxis0 -----------------------------------------------------------

inline
G4bool G4VSurface::IsAxis0(G4int areacode) const 
{
   if (areacode & sAxis0) return true;
   return false;
}

//=====================================================================
//* IsAxis1 -----------------------------------------------------------

inline
G4bool G4VSurface::IsAxis1(G4int areacode) const 
{
   if (areacode & sAxis1) return true;
   return false;
}

//=====================================================================
//* IsOutside ---------------------------------------------------------

inline
G4bool G4VSurface::IsOutside(G4int areacode) const 
{
   if (areacode & sInside) return false;
   return true;
}

//=====================================================================
//* IsInside ----------------------------------------------------------

inline
G4bool G4VSurface::IsInside(G4int areacode, G4bool testbitmode) const 
{
   if (areacode & sInside) {
      if (testbitmode) {
         return true;
      } else {
       if (!((areacode & sBoundary) || (areacode & sCorner))) return true;
      }
   }
   return false;
}

//=====================================================================
//* IsBoundary --------------------------------------------------------

inline
G4bool G4VSurface::IsBoundary(G4int areacode, G4bool testbitmode) const 
{
   if ((areacode & sBoundary) == sBoundary) {
      if (testbitmode) {
         return true; 
      } else {
         if ((areacode & sInside) == sInside) return true;
      }
   }
   return false;
}

//=====================================================================
//* IsCorner ----------------------------------------------------------

inline
G4bool G4VSurface::IsCorner(G4int areacode, G4bool testbitmode) const 
{
   if ((areacode & sCorner) == sCorner) {
      if (testbitmode) {
         return true;
      } else {
         if ((areacode & sInside) == sInside) return true;
      }
   }
   return false;
}

//=====================================================================
//* GetAxisType -------------------------------------------------------

inline
G4int G4VSurface::GetAxisType(G4int areacode, G4int whichaxis) const
{
   G4int axiscode = areacode & sAxisMask & whichaxis;
   
   if (axiscode == (sAxisX & sAxis0) ||
       axiscode == (sAxisX & sAxis1)) {
      return sAxisX;
   } else if (axiscode == (sAxisY & sAxis0) ||
              axiscode == (sAxisY & sAxis1)) {
      return sAxisY;
   } else if (axiscode == (sAxisZ & sAxis0) ||
              axiscode == (sAxisZ & sAxis1)) {
      return sAxisZ;
   } else if (axiscode == (sAxisRho & sAxis0) ||
              axiscode == (sAxisRho & sAxis1)) {
      return sAxisRho;
   } else if (axiscode == (sAxisPhi & sAxis0) ||
              axiscode == (sAxisPhi & sAxis1)) {
      return sAxisPhi;
   } else {
      G4cerr << "ERROR - G4VSurface::GetAxisType()" << G4endl
             << "        areacode = " << areacode << G4endl;
      G4Exception("G4VSurface::GetAxisType()","NotSupported",
                  FatalException, "Configuration not supported.");
   }
   return 1;
}

//=====================================================================
//* ComputeGlobalPoint ------------------------------------------------

inline
G4ThreeVector G4VSurface::ComputeGlobalPoint(const G4ThreeVector &lp) const
{
   return fRot * G4ThreeVector(lp) + fTrans;
}

//=====================================================================
//* ComputeGlobalPoint ------------------------------------------------

inline
G4ThreeVector G4VSurface::ComputeLocalPoint(const G4ThreeVector &gp) const
{
   return fRot.inverse() * G4ThreeVector(gp) - fTrans;
}

//=====================================================================
//* ComputeGlobalDirection --------------------------------------------

inline
G4ThreeVector G4VSurface::ComputeGlobalDirection(const G4ThreeVector &lp) const
{
   return fRot * G4ThreeVector(lp); 
}

//=====================================================================
//* ComputeLocalDirection ---------------------------------------------

inline
G4ThreeVector G4VSurface::ComputeLocalDirection(const G4ThreeVector &gp) const
{
   return fRot.inverse() * G4ThreeVector(gp);
}

//=====================================================================
//* SetNeighbours -----------------------------------------------------

inline
void G4VSurface::SetNeighbours(G4VSurface* axis0min, G4VSurface* axis1min, 
                               G4VSurface* axis0max, G4VSurface* axis1max)
{
   fNeighbours[0] = axis0min;
   fNeighbours[1] = axis1min;
   fNeighbours[2] = axis0max;
   fNeighbours[4] = axis1max;
}

//=====================================================================
//* GetNeighbours -----------------------------------------------------

inline
G4int G4VSurface::GetNeighbours(G4int areacode, G4VSurface** surfaces) 
{
   G4int i = 0;
   
   if (areacode & (sAxis0 | sAxisMin)) {
       surfaces[i] = fNeighbours[0];
       i++;
   }
   if (areacode & (sAxis1 | sAxisMin)) {
       surfaces[i] = fNeighbours[1];
       i++;
       if (i == 2) return i;
   }
   if (areacode & (sAxis0 | sAxisMax)) {
       surfaces[i] = fNeighbours[2];
       i++;
       if (i == 2) return i;
   }
   if (areacode & (sAxis1 | sAxisMax)) {
       surfaces[i] = fNeighbours[3];
       i++;
       if (i == 2) return i;
   }
   
   return i;
}

//=====================================================================
//* GetCorner ---------------------------------------------------------

inline
G4ThreeVector G4VSurface::GetCorner(G4int areacode) const
{
   if (!(areacode & sCorner)){
      G4cerr << "ERROR - G4VSurface::GetCorner()" << G4endl
             << "        areacode = " << areacode << G4endl;
      G4Exception("G4VSurface::GetCorner()","InvalidSetup",
                  FatalException, "Area code must represent corner.");
   }
   
   if ((areacode & sCMin1Min) == sCMin1Min) { 
      return fCorners[0];
   } else if ((areacode & sCMax1Min) == sCMax1Min) { 
      return fCorners[1];
   } else if ((areacode & sCMax1Max) == sCMax1Max) {
      return fCorners[2];
   } else if ((areacode & sCMin1Max) == sCMin1Max) { 
      return fCorners[3];
   } else {
      G4cerr << "ERROR - G4VSurface::GetCorner()" << G4endl
             << "        areacode = " << areacode << G4endl;
      G4Exception("G4VSurface::GetCorner()", "NotSupported",
                  FatalException, "Configuration not supported.");
   }
   return fCorners[0];
}
