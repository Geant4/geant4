// This code implementation is the intellectual property of
// the GEANT4 collaboration.
//
// By copying, distributing or modifying the Program (or any work
// based on the Program) you indicate your acceptance of this statement,
// and all its terms.
//
// $Id: G4NavigationHistory.icc,v 1.3 2000-11-01 16:51:06 gcosmo Exp $
// GEANT4 tag $Name: not supported by cvs2svn $
//
//
// class G4NavigationHistory Inline implementation
//

inline
G4NavigationHistory::G4NavigationHistory()
  : fNavHistory(kHistoryMax), fStackDepth(0)
{
	Reset();	// Reset depth
	Clear();
}

inline
G4NavigationHistory::G4NavigationHistory(const G4NavigationHistory &h)
  : fNavHistory(h.fNavHistory), fStackDepth(h.fStackDepth)
{
}

inline G4NavigationHistory::~G4NavigationHistory()
{
	Reset();	// To delete all but one current entries!
        // delete fNavHistory(0);
}

inline
G4NavigationHistory&
G4NavigationHistory::operator=(const G4NavigationHistory &h)
{
  if (&h == this) return *this;

  // fNavHistory=h.fNavHistory;   // This works, but is very slow.
  if( this->GetMaxDepth() < h.fStackDepth ){
     fNavHistory.reshape( h.fStackDepth ); 
  }
  register G4int ilev= h.fStackDepth;
  for ( ; ilev>=0; ilev--) { 
     fNavHistory(ilev) = h.fNavHistory(ilev); 
  } 

  fStackDepth=h.fStackDepth;

  return *this;
}

inline
void G4NavigationHistory::Reset()
{
	fStackDepth=0;
}

inline
void G4NavigationHistory::Clear()
{
	G4AffineTransform dummyTransform(G4ThreeVector(0.));

	G4NavigationLevel  tmpNavLevel;
	tmpNavLevel=G4NavigationLevel(0, dummyTransform, kParameterised, -1) ;

	Reset();
	for (G4int ilev=fNavHistory.length()-1; ilev>=0; ilev--)
	{
	   // fNavHistory(ilev)= 0;
	   fNavHistory(ilev)= tmpNavLevel;
	}
}

inline
void G4NavigationHistory::SetFirstEntry(G4VPhysicalVolume* pVol)
{
	G4ThreeVector translation(0.,0.,0.);

   	// Protection needed in case pVol=null 
        //   so that a touchable-history can signal OutOfWorld 
	//   
	if(pVol !=0) {
	    translation=pVol->GetTranslation();
	}
	fNavHistory(0)= G4NavigationLevel( pVol,
					   G4AffineTransform(translation), 
					   kNormal );
}

inline
const G4AffineTransform* G4NavigationHistory::GetPtrTopTransform() const
{
	return   fNavHistory(fStackDepth).GetPtrTransform();
}

inline
const G4AffineTransform& G4NavigationHistory::GetTopTransform() const
{
	return fNavHistory(fStackDepth).GetTransform();
}

inline
G4int G4NavigationHistory::GetTopReplicaNo() const
{
	return fNavHistory(fStackDepth).GetReplicaNo();
}

inline
EVolume G4NavigationHistory::GetTopVolumeType() const
{
	return fNavHistory(fStackDepth).GetVolumeType();
}

inline
G4VPhysicalVolume* G4NavigationHistory::GetTopVolume() const
{
	return fNavHistory(fStackDepth).GetPhysicalVolume();
}

inline
G4int G4NavigationHistory::GetDepth() const
{
	return fStackDepth;
}

inline
const G4AffineTransform&
G4NavigationHistory::GetTransform(G4int n) const
{
	return fNavHistory(n).GetTransform();
}

inline
G4int G4NavigationHistory::GetReplicaNo(G4int n) const
{
	return fNavHistory(n).GetReplicaNo();
}

inline
EVolume G4NavigationHistory::GetVolumeType(G4int n) const
{
	return fNavHistory(n).GetVolumeType();
}

inline
G4VPhysicalVolume* G4NavigationHistory::GetVolume(G4int n) const
{
	return fNavHistory(n).GetPhysicalVolume();
}

inline
G4int G4NavigationHistory::GetMaxDepth() const
{
	return fNavHistory.length();
}

inline
void G4NavigationHistory::BackLevel()
{
	assert(fStackDepth>0);

        //  Tell  the  level  that I am forgetting it
        // delete fNavHistory(fStackDepth); 
        fStackDepth--;
}

inline
void G4NavigationHistory::BackLevel(G4int n)
{
	assert(n<=fStackDepth);
        fStackDepth-=n;
}

inline
void G4NavigationHistory::EnlargeHistory()
{
	G4int len=fNavHistory.length();
	if (len==fStackDepth)
		{       // Note: Resize operation clears additional entries
			G4int nlen=len+kHistoryStride;
			fNavHistory.reshape(nlen);
		}	
}


inline
void G4NavigationHistory::NewLevel(G4VPhysicalVolume *pNewMother,
				   EVolume vType,
				   G4int nReplica)
{
	EnlargeHistory();	// Enlarge if required
	fStackDepth++;
	fNavHistory(fStackDepth) = 
	       G4NavigationLevel(pNewMother, 
				 fNavHistory(fStackDepth-1).GetTransform(),
				 G4AffineTransform(pNewMother->GetRotation(),
						pNewMother->GetTranslation()),
				 vType,
				 nReplica); 
	// The constructor computes the new global->local transform
}
