// This code implementation is the intellectual property of
// the GEANT4 collaboration.
//
// By copying, distributing or modifying the Program (or any work
// based on the Program) you indicate your acceptance of this statement,
// and all its terms.
//
// $Id: G4FieldTrack.icc,v 1.5 2001-02-20 18:15:40 japost Exp $
// GEANT4 tag $Name: not supported by cvs2svn $
//
#include "PhysicalConstants.h"

inline
G4FieldTrack::G4FieldTrack( const G4ThreeVector& pPosition, 
			    const G4ThreeVector& pMomentumDirection,    
			          G4double       curve_length, 
			          G4double       kineticEnergy,
			    const G4double       restMass_c2,
			          G4double       velocity,
			          G4double       pLaboratoryTimeOfFlight,
			          G4double       pProperTimeOfFlight,
			    const G4ThreeVector* pSpin)
 : fKineticEnergy(kineticEnergy),
   fLabTimeOfFlight(pLaboratoryTimeOfFlight), 
   fProperTimeOfFlight(pProperTimeOfFlight),
   fMomentumDir(pMomentumDirection),
   fRestMass_c2(restMass_c2)
{
  G4double momentum  = sqrt(kineticEnergy*kineticEnergy
                            +2.0*restMass_c2*kineticEnergy);

  G4ThreeVector pMomentum= momentum * pMomentumDirection; 

  SetCurvePnt( pPosition, pMomentum, curve_length );
  if(pSpin) fSpin = *pSpin;
}

inline
G4FieldTrack::G4FieldTrack( const G4FieldTrack&  rStVec  )
 : fDistanceAlongCurve( rStVec.fDistanceAlongCurve),
   fKineticEnergy( rStVec.fKineticEnergy ),
   fRestMass_c2( rStVec.fRestMass_c2),
   fLabTimeOfFlight( rStVec.fLabTimeOfFlight ), 
   fProperTimeOfFlight( rStVec.fProperTimeOfFlight ), 
   fMomentumModulus( rStVec.fMomentumModulus ),
   fSpin( rStVec.fSpin ), 
   fMomentumDir( rStVec.fMomentumDir )
{
  SixVector[0]= rStVec.SixVector[0];
  SixVector[1]= rStVec.SixVector[1];
  SixVector[2]= rStVec.SixVector[2];
  SixVector[3]= rStVec.SixVector[3];
  SixVector[4]= rStVec.SixVector[4];
  SixVector[5]= rStVec.SixVector[5];
 // Old code:
  // SetCurvePnt(rStVec.GetPosition(), 
  //	      rStVec.GetMomentumDir(), 
  // 	      rStVec.GetCurveLength() );   // Slow, so changed it
}

inline
G4FieldTrack::~G4FieldTrack()
{
}

inline G4FieldTrack& 
G4FieldTrack::SetCurvePnt(const G4ThreeVector& pPosition, 
			  const G4ThreeVector& pMomentum,  // Can be Unit
			        G4double       s_curve )
{
  SixVector[0] = pPosition.x(); 
  SixVector[1] = pPosition.y(); 
  SixVector[2] = pPosition.z(); 

  SixVector[3] = pMomentum.x(); 
  SixVector[4] = pMomentum.y(); 
  SixVector[5] = pMomentum.z(); 

  fMomentumDir = pMomentum.unit();

  fDistanceAlongCurve= s_curve;

  return *this;
} 

inline
G4ThreeVector G4FieldTrack::GetPosition() const
{
   G4ThreeVector myPosition( SixVector[0], SixVector[1], SixVector[2] );
   return myPosition;
} 

inline
void G4FieldTrack::SetPosition( G4ThreeVector pPosition) 
{
   SixVector[0] = pPosition.x(); 
   SixVector[1] = pPosition.y(); 
   SixVector[2] = pPosition.z(); 
} 

inline
const G4ThreeVector& G4FieldTrack::GetMomentumDir() const 
{
   // G4ThreeVector myMomentum( SixVector[3], SixVector[4], SixVector[5] );
   // return myVelocity;
   return fMomentumDir;
} 

inline
G4double  G4FieldTrack::GetCurveLength() const 
{
     return  fDistanceAlongCurve;  
}

inline
void G4FieldTrack::SetCurveLength(G4double nCurve_s)
{
     fDistanceAlongCurve= nCurve_s;  
}

// #ifdef ENERGY_OK
inline
G4double  G4FieldTrack::GetKineticEnergy() const
{
   return fKineticEnergy;
}
// #endif

inline
void G4FieldTrack::SetKineticEnergy(G4double newKinEnergy)
{
   fKineticEnergy=newKinEnergy;
}

inline
G4ThreeVector G4FieldTrack::GetSpin() const
{
   return fSpin;
}

inline
void G4FieldTrack::SetSpin(G4ThreeVector nSpin)
{
   fSpin=nSpin;
}

inline
G4double G4FieldTrack::GetLabTimeOfFlight() const
{
   return fLabTimeOfFlight;
}

inline
void G4FieldTrack::SetLabTimeOfFlight(G4double nTOF)
{
   fLabTimeOfFlight=nTOF;
}

inline
G4double  G4FieldTrack::GetProperTimeOfFlight() const
{
   return fProperTimeOfFlight;
}

inline
void G4FieldTrack::SetProperTimeOfFlight(G4double nTOF)
{
   fProperTimeOfFlight=nTOF;
}

inline
G4double G4FieldTrack::GetMomentumModulus() const
{
   return fMomentumModulus;
}

inline
void G4FieldTrack::SetMomentumModulus(G4double nMomentumMod)
{
   fMomentumModulus= nMomentumMod;         // does not modify energy
}

inline
void G4FieldTrack::SetMomentumDir(G4ThreeVector newMomDir)
{
   fMomentumDir= newMomDir;
}

inline
G4ThreeVector G4FieldTrack::GetMomentum() const 
{
   return G4ThreeVector( SixVector[3], SixVector[4], SixVector[5] );
} 

inline
void G4FieldTrack::SetMomentum(G4ThreeVector pMomentum)
{
  SixVector[3] = pMomentum.x(); 
  SixVector[4] = pMomentum.y(); 
  SixVector[5] = pMomentum.z(); 

  fMomentumDir = pMomentum.unit(); 
}

// Dump values to array
//  
//   note that momentum direction is not saved 

inline
void G4FieldTrack::DumpToArray(G4double valArr[ncompSVEC] ) const
{
  valArr[0]=SixVector[0];
  valArr[1]=SixVector[1];
  valArr[2]=SixVector[2];
  valArr[3]=SixVector[3];
  valArr[4]=SixVector[4];
  valArr[5]=SixVector[5];

  G4ThreeVector Momentum(valArr[3],valArr[4],valArr[5]);
  G4double      Momentum_mag_sq = Momentum.mag2();

  // G4double mass_in_Kg;
  // mass_in_Kg = fEnergy / velocity_mag_sq * (1-velocity_mag_sq/c_squared);
  // valArr[6]= mass_in_Kg;

  // The following components may or may not be integrated.
  valArr[6]= fKineticEnergy; 

  // valArr[6]=fEnergy;  // When it is integrated over, do this ...
  valArr[7]=fLabTimeOfFlight;
  valArr[8]=fProperTimeOfFlight;
  valArr[9]=fSpin.x();
  valArr[10]=fSpin.y();
  valArr[11]=fSpin.z();
  // valArr[13]=fMomentumDir.x(); 
  // valArr[14]=fMomentumDir.y();
  // valArr[15]=fMomentumDir.z();
  // valArr[]=fDistanceAlongCurve; 
}

// Load values from array
//  
//   note that momentum direction must-be/is normalised

inline
void G4FieldTrack::LoadFromArray(G4double valArr[ncompSVEC])
{
  SixVector[0]=valArr[0];
  SixVector[1]=valArr[1];
  SixVector[2]=valArr[2];
  SixVector[3]=valArr[3];
  SixVector[4]=valArr[4];
  SixVector[5]=valArr[5];

  G4ThreeVector Momentum(valArr[3],valArr[4],valArr[5]);

  G4double momentum_square= Momentum.mag2();
  fMomentumDir= Momentum.unit();

  fKineticEnergy = momentum_square / 
                   (sqrt(momentum_square+fRestMass_c2*fRestMass_c2)
                     + fRestMass_c2 ); 
  // The above equation is stable for small and large momenta

  // The following components may or may not be
  //    integrated over -- integration is optional
  // fKineticEnergy= valArr[6];

  fLabTimeOfFlight=valArr[7];
  fProperTimeOfFlight=valArr[8];
  fSpin=G4ThreeVector(valArr[9],valArr[10],valArr[11]);
  // fMomentumDir=G4ThreeVector(valArr[13],valArr[14],valArr[15]);
  // fDistanceAlongCurve= valArr[]; 
}
  
inline
G4FieldTrack & G4FieldTrack::operator = ( const G4FieldTrack& rStVec )
{
  if (&rStVec == this) return *this;

  // SetCurvePnt(rStVec.GetPosition(), 
  //	      rStVec.GetMomentumDir(), 
  //	      rStVec.GetCurveLength() );
  SixVector[0]= rStVec.SixVector[0];
  SixVector[1]= rStVec.SixVector[1];
  SixVector[2]= rStVec.SixVector[2];
  SixVector[3]= rStVec.SixVector[3];
  SixVector[4]= rStVec.SixVector[4];
  SixVector[5]= rStVec.SixVector[5];
  SetCurveLength( rStVec.GetCurveLength() );

  SetKineticEnergy(  rStVec.fKineticEnergy );
  SetLabTimeOfFlight( rStVec.GetLabTimeOfFlight()  ); 
  SetProperTimeOfFlight( rStVec.GetProperTimeOfFlight()  ); 
  SetSpin( rStVec.GetSpin() );
  SetMomentumModulus( rStVec.GetMomentumModulus());
  SetMomentumDir( rStVec.fMomentumDir );

  return *this;
}
