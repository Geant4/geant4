<html>
<head>
<title>
MOMO Help
</title>
</head>
<body>
<center>
<h1>
<A NAME="TOP">MOMO; Integrated GUI desktop for Geant4 development
</A></h1><br>
					November 25, 2004
<br>
                                        Hajime YOSHIDA
<br>
                                        Naruto University of Education
</center>

<hr>
<H1>Index</H1><p>
<OL>
<LI><A HREF="#1">MOMO and its derived versions </A>
<LI><A HREF="#2">How to develop Geant4 detector, physics list, 
main program, and makefile, using MOMO </A>
<LI><A HREF="#3">GGE Geant4 Geometry Editor </A>
<OL>
<LI><A HREF="#3-1">Characteristics</A>
<LI><A HREF="#3-2"> Material Editor and Volume Editor</A>
<LI><A HREF="#3-3"> Menus of GGE</A>
<LI><A HREF="#3-4"> Material Editor </A>
<OL>
<LI><A HREF="#3-4-1">Periodic Table of Elements </A>
<LI><A HREF="#3-4-2">Functionalities of the Material Editor </A>
</OL>
<LI><A HREF="#3-5">The Logical Volume Editor </A>
<OL>
<LI><A HREF="#3-5-1"> Functionalities to define Geant4 logical volumes</A>
</OL>
<LI><A HREF="#3-6">The Physical Volume Editor </A>
<OL>
<LI><A HREF="#3-6-1"> Limit of Physical volumes Editor</A>
<LI><A HREF="#3-6-2">Constructors of G4PVPlacement </A>
<LI><A HREF="#3-6-3"> Single Positioned Volume</A>
<LI><A HREF="#3-6-4">Repeated Translationally Positioned Volumes </A>
<LI><A HREF="#3-6-5">Repeated Rotationally Positioned Volumes </A>
<LI><A HREF="#3-6-6">Replica in the X, Y or Z direction, Replica in rho, phi or Z direction </A>
</OL>
<LI><A HREF="#3-7"> Generation of C++ code</A>
<OL>
<LI><A HREF="#3-7-1">Naming conventions in GGE </A>
<LI><A HREF="#3-7-2"> Default values and combo-boxes</A>
</OL>
</OL>

<LI><A HREF="#4">GPE Geant4 Physics Editor </A>
<OL>
<LI><A HREF="#4-1"> Particle</A>
<LI><A HREF="#4-2">EM Processes </A>
<LI><A HREF="#4-3">C++ codes generated by GPE </A>
<LI><A HREF="#4-4">Persistent file </A>
</OL>



<LI><A HREF="#5">MOMO's Companion Files </A>
<OL>
<LI><A HREF="#5-1">Momomake.gmk generated by MOMO </A>
<LI><A HREF="#5-2">Main program generated by MOMO </A>
</OL>
<LI><A HREF="#10.5">Makefiles and Environment Variables
 </A>

<LI><A HREF="#7">GAG and Gain </A>
<OL>
<LI><A HREF="#7-1">GAG </A>
<LI><A HREF="#7-2">Gain </A>
</OL>
</OL>

<A HREF="#TOP">TOP</A>

<A NAME="1"><FONT color=#238e23 size=+3><B>1) MOMO and its derived versions </B></FONT>
</A><br>
<HR>

Momo is conceived as a kind of integrated GUI desktop for Geant4
which combines existing  tools like GGE (Geant4 Geometry Editor), 
GPE (Geant4 Physics Editor), GAG (Geant4 Adaptive GUI) 
and Gain (Geant4 adaptive interface for network).

It also  provides user with the capability to create a makefile reflecting his 
environment variables, to create a simple main program which utilises
C++ source codes generated by GGE and GPE and to compile a running application. 

It is completely written in Java and runs on
any platform running Java like Linux, Windows and Mac. 
Currently supported is Java 1.4 (some functions don't work well with Java 1.5).

At present time, there are three versions of MOMO, which have different way
to start.
<DL>
<DT> Stand-alone version
<DD>It must be started in the console, using "java" command. 
The jar (Java archive) file MOMO.jar of the standalone version can 
be downloaded from the site below:
  <a href="http://erpc1.naruto-u.ac.jp/~geant4/Sources.html">Naruto Web server</a>

When its environment and a set of
companion files are prepared  (explained later), MOMO is capable of
creating C++ main program, GNU makefile and compiling to make a
running program.

GAG (Geant4 Adaptive GUI) and gain (Geant4 adaptive interface for network)
are available to steer
the execution of Geant4 and are integrated in the present version of MOMO.
<DT>Java Web Start version
<DD>
This version is of exactly the same MOMO as
 the stand-alone version with digital signature. When user clicks it in
the Web browser, the jar file is downloaded automatically. Then, it asks
him whether he wants to start it, trusting the signature.
<DT> MomoPlugin to JAS3
<DD> JAS3, when loaded with MomoPlugin.jar,
offers similar functionalities as above.
The current version of MomoPlugin.jar lacks some functions
(creating main program, and makefile) found in 
the stand-alone version, as explained below.

The plugin version can be
used in conjunction with G4Plugin which steers the execution of
Geant4. MomoPlugin and G4Plugin are available at SLAC.

The main program must use G4UIrmi class to
connect to G4Plugin. The front-end class G4UIrmi has a stronger point
that G4UIGAG in that it is multi-threaded. So, user of G4Plugin + G4UIrmi
can stop the execution of a long run without exiting, needless to say
the powerful integrated environment for code development, 
steering the execution of simulation and analysing the results.
This manual doesn't treat this interesting plugin. 
</DL>

<hr>
<A HREF="#TOP">BACK</A><BR>
<A NAME="2"><FONT color=#238e23 size=+3><B>
2) How to develop detector, physics list, main program, and makefile, using MOMO </B></FONT></A>
<HR>
Using MOMO,
user can create geometry, physics, main C++ classes and a makefile, 
compile them with Geant4 libraries. Schematical diagram is shown below.

<pre>
   GGE             GPE            MOMO or User    MOMO Env. Panel  MOMO companions
    |               |                 |              |                   |
 Geometry.cc   PhysicsList.cc    MySimulation.cc  makefile         *.cc *.hh
    |               |                 |              |                   |
 Geometry.o    PhysicsList.o     MySimulation.o   Momomake.gmk          *.o
       \             \                |             /                  /
                                 Mysimulation
                                      /\
                                      ||
                                 GAG / Gain / G4Plugin
</pre>

<hr>

All versions of MOMO, in common,  offers the following key functions;
<UL>
<li> GGE  to create detector C++ class files
<li> GPE  to create physics list C++ class files
<li> Environment Panel to see and set the Geant4 environment variables which are used in the makefile generated by MOMO
<li>GAG to start a Geant4 application and to steer its execution
<li>Gain to start a Geant4 application at a remote site and to steer its execution

</UL>

MOMO has the extra  menus;

<OL>
<LI>"Project" menus
<UL>
<li> the button to create a  simple working main program which uses G4UIGAG interface and visualization drivers which are set on the MOMO's Env panel,
<li> the button to create a Makefile using the environment variables
set in the "Environment Panel". This makefile is made so that the
environment variables set by the user within the "Environment Panel"
oversede the ones defined in the parent terminal/login shell.
<LI> the button to compile all the files generated by MOMO and a set
of companion files to make a running Geant4 executable file. 
</UL>
<LI>Help menu
This document is displayed.

</OL>
MOMO is helped by the followings;

<UL>

<li> A set of  companion files complement the C++ source files generated by MOMO. 
They are stored in the canonical directory structure of Geant4.
Among them are mandatory user-defined class and visualization manager.
So MOMO with the companion files provide a complete set of
running Geant4 simulation, as explained later. 
<li>Examplary MOMO's persistent
files of geometry and physics list are also included for demonstration.

</UL>


<hr>
</A><A HREF="#TOP">BACK</A>
<BR><A NAME="3"><FONT color=#238e23 size=+3><B>
3) GGE Geant4 Geometry Editor</B></FONT>
<BR>
<hr>

 GGE, or GEANT4 Geometry  Editor,  is a  tabular tool to "create"  a
detector geometry of GEANT4. 
From the rows of the tables, filled by user, it generates a <font color=green>
complete C++ class code lines</font> for  materials and logical volumes.

It is capable of limited  and relatively simple cases of the full geometry,
including physical volumes, i.e., placing of logical volumes. 
<A NAME="3-1"><h3>
3-1) Characteristics
</h3>
</A><A HREF="#TOP">BACK</A>
<DL>
<DT>Tables
<DD>It provides users with several tables
into whose cells  users can fill  with their own detector parameters.
Each row of the tables corresponds to a kind of instantiation or
application of a certain method of a class.
<DT>Help user with Geant4 defaults
<DD>Default values, canonical units of Geant4, pre-defined Geant4 constants
etc. are visually provided for user's choice. 
<DT>C++ code generation  
<DD>Using the data in the tables, even if they are partial and imcomplete, 
GGE can generate C++ source codes  for a detector,
only if the class name of the geometry is supplied.
<br>
If user wants so, C++ codes  generated by GGE can be a complete
description of a detector, including the definition of atoms, materials, 
solids, color attributes,
logical volumes and physical volumes with rotations and translations.
  <ul>
  <li>All necessary class names and their usages of the Geant4 class libraries
  are applied  in automatic C++ code generation
  <li>All necessary class definition files are included automatically
  <li>Necessary local variables such as to define the rotation or translation 
  are created when necessary. Naming conventions are explained later.

  <li>The C++ source codes are saved into files and can be compiled to 
    make a GEANT4 executable.
  </ul>
<DT>Persistency and Reuse of detector data
<DD> Full detector data and material data can be 
saved in the Java's serialization format or in the XML format a la GDML-1. 
It can be reloaded for later reuse.

XML format a la GDML-1 is limited to materials and logical volumes.  
But XML file 
lacks some items in the MOMO's table due 
to GDML-1's present imcompleteness. Physical volumes aren't
supported.
<DT>Companion files and Extra "Project" functions
<DD>

<UL>
<li>
A set of companion files are provided to visualize the geometry and
to run the simulation with the physics list. Files generated by GGE and GPE
must be stored in the canonical sub-directories, therein.

Details will be explained later.
<li>The stand-alone version of MOMO provides three menu buttons;
 <ul>
 <li>to generate a simple working main program. User has to supply the
name of the main program, which MOMO uses for the G4TARGET.
 <li>to generate Momomake.gmk makefile. The environment variables set by
a user are included in the Momomake.gmk.
 <li>to compile all. If MOMOHOME variable is defined to designate the
 position of the companion files, MOMO starts make command. Or user can
use this makefile like;
<pre>
      %make -f Momomake.gmk
</pre>

 </DL>

</ol>

<hr>
</A><A HREF="#TOP">BACK</A><BR>
<A NAME="3-2">
<h3>3-2) Material Editor and Volume Editor</h3>
<BR>

 GGE   consists  of  two tabular editors (material   and   volume)  which  are
interrelated. <br>

The material editor consists of two tables; one for "material from scratch", another
for "compound materials".
<br>
 Volume editor   consists of two minor editors; 
one for "logical volumes" and another for
"physical volumes". The logical volume editor allows user to specify complete
description of logical volumes,
including solid, material, and visualization attribute.
<br>
The Physical volume editor, in contrast, supports  only limited use-cases ; <it>Single
Positioned Volume</it>,  <it>Repeatedly Positioned  Volumes</it>  with  incremental  copy numbers
(translational arrangement or axially symmetric arrangement), and
<it>Replicas </it>(in any axis).

<p>
<font color=red>Tips!</font>
<ol>
<li>GGE/MOMO is based on Java's MVC (Model-View-Control) model, so that any changes
to any of the tables by a user
are automatically reflected to the internal data structure of GGE and thus to C++ codes.
This is true at any moment, so that user can get even imcomplete C++ class files
at any moment, even without any filled tabular cells, though only the 
class name is mandatory.
<li>
The whole detector description can be saved in a persistent file and can
be loaded for later reuse.
<li>


GGE employs own naming rules to generate C++ codes from the tables. This will
be explained later.
</ol>
<hr>
</A><A HREF="#TOP">BACK</A><BR>
<A NAME="3-3">
<h3>3-3) Menus of GGE</h3>
<BR>

GGE has a top menu buttons and fill-in text area.


<ul>
<li> text area to specify the class name. This is mandatory to save data or to create C++ source codes.
<li> menu buttons; Material editor, Volume editor
	<ul>
	<li> load, save a persistent file
	   <ul>
	    <li>Java Serialization data format (MOMO-standards),
	      the compatibility with the future version of MOMO isn't garuanteed.
	    <li>XML format (not recommended though with limited functions)
	    </ul>
	<li> clear the tables
	<li> generate cc and hh files using the specified class name (Volume editor)
	</ul> 
</ul>
<A NAME="3-4">
<h3>3-4) Material Editor </h3> <br>
</A><A HREF="#TOP">BACK</A>
<BR>
The material editor
is composed of two minor tables for 
<ol>
<li>"material from scratch"
and 
<li>"compound materials".
</ol>
 These tables can be enlengthened as will, if necessary.
The boundary of the two tables can be moved as will, too.
<br>

Every row corresponds to one material (scratch or compound). 
A row is filled with selected element(s) and default values, when
user push the "append" or "insert" button, after selecting a element(s).

<hr>
</A><A HREF="#TOP">BACK</A><BR>
<A NAME="3-4-1">
<h3>3-4-1) Periodic Table of Elements</h3>
<BR>
The periodic table is popped up, 
when one of the "append" or "insert" buttons of the tables is pushed.
<br>
When an element is chosen by the mouse click, it's label color becomes green. 
Multiple elements (upto 20 at present)
can be chosen simultaneously for compound materials.
When a mouse is clicked on the selected element, is is deselected. So, user
can choose correct element(s).
<br>
The foundamental properties of atoms; Z, A, etc. are pre-built in to the
atomic table and are copied automatically to the table.
They are also used to create
C++, XML and Java serialization files,
even though unseen to the user.
<br>
The element window can be hidden at any moment by the close
button of the window.

<hr>
<A NAME="3-4-2">
</A><A HREF="#TOP">BACK</A><BR>
<h3>
3-4-2) Functionalities of the Material Editor
</h3>

<br>

The following functionalities are  implemented;
<ol>
<li> <strong>append, insert, edit and delete</strong> a material
	<ul>
	 <li>    <strong>material from scratch</strong><br>
		 The  name of an atom, numbers Z and A are 
		 taken from the atomic table. User has to specify its density,
		temperature and pressure. Canonical units and states can be 
		choosen	from the listbox.<br> Although the scratch table shows
	   the names of the elements in the second column,
		 the corresponding instance in C++ is named "elementX", where
		"X" represents element's symbol, like "elementH", "elementNa".
	 <li>    <strong> material by combination </strong>(number or fractional ratios). <br>
	   When element(s) is(are) chosen in the  periodic table of 
	   atoms</a>, it(they) is(are) copied to tha table of 
           scratch(compound) on the pression of "append" 
	   or "insert" button. 
           <br>If user selected multiple elements and pushed
           "insert" or "append" button of the scratch table, only the 
            first element is copied. When the button of the compound table 
            is pushed, all the selected elements are shown in the third column.
	   <br>
	   To "insert" a row, user
	   has to focus a row before the click on the menu button. A new row
	   is created just below it.
	   <li>	 User has to type in the name of a compound material, 
	   which is employed as the variable name in verbatim.
	 <li>A pop-up window 
	   is displayed when he focuses and click
		 on a third cell with the label "elements". 
	   There, compound by number or by fraction can be specified. 
	   The values are copied to the "elements" cell. To confirm, user
	   can enlarge the width of the cell.
	  <li> default  states (and their canonical names) 
		 and values are provided  (material state, temperature, 
		 pressure). 
	  <li> canonical physical units  of GEANT4 
		 are shown in selectable combo-boxes.
	  </ul>
        <li> The first column "<strong>in Use</strong>"  is to mark the
	 materials used in user's detector (logical volumes).
	 The default value is "in Use", when a row is created at the first time. 
	  <ul>
	  <li>   Only materials used in the logical volumes can be 
		 automatically checked and marked as "in Use" state by 
	    the "Mark the Used Materials" button
		 on the Logical Volume Table, as seen below. 
	   <li>  user can add any materials "in Use" to 
		 have C++ constructors, even when they aren't used in 
		 logical volumes.
	   </ul>
<li>	<strong> input and output from/to persistent material file </strong>
	<br>
	Material tables are saved to a Java's persistent file and can be 
	reused. XML a la GDML format is also provided. Note that GDML is not yet
	complete and is lacking a part of definitions like material's state etc.
	   <ul>
	   <li>   load, append or save a material file
	    <li>  exemplary persistent material database 
		 file  "PDG.g4mt"  and PDG.xml taken from the PDG data book
		 are available.
	    </ul>
</ol>

Not yet implemented are;  
<ul>
  <li>material from materials, 
  <li>isotope
</ul>
Notice on C++ codes<br>
MOMO doesn't duplicate the C++ instance of an element, but
 is not protected against possible duplication
of "in Use" instances of the same name of compound materials.
<br>
<hr>
<h3>3-4-3) A code fragment generated from the dicom.xml; XML file.</h3>
<pre>
// Elements
G4Element* elementH = new G4Element( "Hydrogen", "H", 1. , 1.00794*g/mole );
G4Element* elementC = new G4Element( "Carbon", "C", 6. , 12.011*g/mole );
G4Element* elementN = new G4Element( "Nitrogen", "N", 7. , 14.00674*g/mole );
G4Element* elementO = new G4Element( "Oxygen", "O", 8. , 15.9994*g/mole );
G4Element* elementNa = new G4Element( "Sodium", "Na", 11. , 22.989768*g/mole );
G4Element* elementMg = new G4Element( "Magnesium", "Mg", 12. , 24.305*g/mole );
G4Element* elementP = new G4Element( "Phosphorus", "P", 15. , 30.973762*g/mole );
G4Element* elementS = new G4Element( "Sulfur", "S", 16. , 32.066*g/mole );
G4Element* elementCl = new G4Element( "Chlorine", "Cl", 17. , 35.4527*g/mole );
G4Element* elementK = new G4Element( "Potassium", "K", 19. , 39.0983*g/mole );
G4Element* elementCa = new G4Element( "Calcium", "Ca", 20. , 40.078*g/mole );
G4Element* elementFe = new G4Element( "Iron", "Fe", 26. , 55.845*g/mole );

// Materials from Combination

G4Material* SkeletonSpongiosa = new G4Material("SkeletonSpongiosa",  1159.0*kg/m3, 
     12, kStateUndefined, 273.15*kelvin, 1.0*atmosphere );
SkeletonSpongiosa->AddElement( elementH, 0.085 );
SkeletonSpongiosa->AddElement( elementC, 0.404 );
SkeletonSpongiosa->AddElement( elementN, 0.058 );
SkeletonSpongiosa->AddElement( elementO, 0.367 );
SkeletonSpongiosa->AddElement( elementNa, 0.0010 );
SkeletonSpongiosa->AddElement( elementMg, 0.0010 );
SkeletonSpongiosa->AddElement( elementP, 0.034 );
SkeletonSpongiosa->AddElement( elementS, 0.0020 );
SkeletonSpongiosa->AddElement( elementCl, 0.0020 );
SkeletonSpongiosa->AddElement( elementK, 0.0010 );
SkeletonSpongiosa->AddElement( elementCa, 0.044 );
SkeletonSpongiosa->AddElement( elementFe, 0.0010 );

</pre>
<hr>
The above C++ lines are generated from the next fragments of XML file a la GDML
which was created by MOMO which reloaded this XML file.

<PRE>

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;gdml xmlns:gdml="http://cern.ch/2001/Schemas/GDML"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:noNamespaceSchemaLocation="../schema/gdml_1.0.xsd"&gt;
&lt;!--skip--&gt;

  &lt;materials&gt;
     &lt;!--Elements--&gt;
     &lt;element name="Hydrogen" formula="H" Z="1"&gt;
      &lt;atom value="1.00794"/&gt;
     &lt;/element&gt;
     &lt;element name="Carbon" formula="C" Z="6"&gt;
      &lt;atom value="12.011"/&gt;
     &lt;/element&gt;
     &lt;element name="Nitrogen" formula="N" Z="7"&gt;
      &lt;atom value="14.00674"/&gt;
     &lt;/element&gt;
     &lt;element name="Oxygen" formula="O" Z="8"&gt;
      &lt;atom value="15.9994"/&gt;
     &lt;/element&gt;
     &lt;element name="Sodium" formula="Na" Z="11"&gt;
      &lt;atom value="22.989768"/&gt;
     &lt;/element&gt;
     &lt;element name="Magnesium" formula="Mg" Z="12"&gt;
      &lt;atom value="24.305"/&gt;
     &lt;/element&gt;
     &lt;element name="Phosphorus" formula="P" Z="15"&gt;
      &lt;atom value="30.973762"/&gt;
     &lt;/element&gt;
     &lt;element name="Sulfur" formula="S" Z="16"&gt;
      &lt;atom value="32.066"/&gt;
     &lt;/element&gt;
     &lt;element name="Chlorine" formula="Cl" Z="17"&gt;
      &lt;atom value="35.4527"/&gt;
     &lt;/element&gt;
     &lt;element name="Potassium" formula="K" Z="19"&gt;
      &lt;atom value="39.0983"/&gt;
     &lt;/element&gt;
     &lt;element name="Calcium" formula="Ca" Z="20"&gt;
      &lt;atom value="40.078"/&gt;
     &lt;/element&gt;
     &lt;element name="Iron" formula="Fe" Z="26"&gt;
      &lt;atom value="55.845"/&gt;
     &lt;/element&gt;

     &lt;!--Materials from Combination--&gt;
     &lt;material name="SkeletonSpongiosa"&gt;
         &lt;D type="denstiy" value="1159.0" unit="kg/m3"/&gt;
         &lt;T type="temperature" value="273.15" unit="kelvin"/&gt;
         &lt;P type="pascal" value="1.0" unit="atmosphere"/&gt;
         &lt;fraction n="0.085" ref="H"/&gt;
         &lt;fraction n="0.404" ref="C"/&gt;
         &lt;fraction n="0.058" ref="N"/&gt;
         &lt;fraction n="0.367" ref="O"/&gt;
         &lt;fraction n="0.0010" ref="Na"/&gt;
         &lt;fraction n="0.0010" ref="Mg"/&gt;
         &lt;fraction n="0.034" ref="P"/&gt;
         &lt;fraction n="0.0020" ref="S"/&gt;
         &lt;fraction n="0.0020" ref="Cl"/&gt;
         &lt;fraction n="0.0010" ref="K"/&gt;
         &lt;fraction n="0.044" ref="Ca"/&gt;
         &lt;fraction n="0.0010" ref="Fe"/&gt;
     &lt;/material&gt;
&lt;!--skip--&gt;
&lt;/gdml&gt;

</PRE>

<hr>

</A><A HREF="#TOP">BACK</A><BR>
<A NAME="3-5">
<h2>
 3-5) The Logical Volume Editor
</h2>

<br>

The logical volume editor is composed of 
<UL>
<LI>three buttons; "append", "insert" and "delete"
<LI>the logical volume table;
<br>
Each row in the table corresponds to an instantiation of
a Geant4 logical or physical volume constructor. Its arguments
are specified in the other cells of the row.
<LI>the button "Mark the Used Materials"
<LI>the editor for visualization attributes<br>
When "create" button is pressed, a color chooser popps up. By choosing a color
and typing its name, it is copied in the editor.
</UL>

<A NAME="3-5-1">
<h3>
3-5-1) Functionalities of the logical volume editor
</h3>
</A><A HREF="#TOP">BACK</A><br>

Following functionaliteis are implemented;
 <ol>
  <li> <strong> Defining G4LogicalVolumes </strong> <br>
     Each row of the logical vulume table represents an
     instance of the G4LogicalVolume constructor.
     User can append, insert or delete a row with corresponding buttons.<br>
	The table has following columns;
      <ul>
	<li>The first column is to specify  the name of a logical volume.
	<li> The second column is filled automatically by choosing one of the 
	G4Solid types from the listbox. <br>
	By clicking on the cell,  user has a pop-up window
		to edit its parameters and preview with DAWN.
	<li> The third column is type-in cell for material name
		 listed in the material editor. All the items already
	         defined in the Material editor are diaplayed in the form
	         of the listbox only to choose one.
	<li> The fourth column is to specify the visualization attribute's  
	  name. All the color names defined in the color chooser lists are
	  displayed to choose one.
	</ul>

 <li> <strong>Selecting a G4Solid</strong><br>
   All Geant4 solids can be selected from the solid listbox, located at the 
   right of "Select a Solid" label.
     <ul>
	<li>all CSG solids;  box, tube segment, cone segment, 
	symmetric trapezoid, sphere segment, parallel piped, 
	torus segment, HYPE,
	<li>BREP solids; PolyCone segment and Polygone segment
     </ul>
 <li> After selecting a solid tyle, user pushes the "append" or "insert" button
	and a new row is created in the table. 
 <li>By clicking on the "solid" cell (the second column), 
	a pop up
	window  appears to specify solid's parameters. User can   
		<ul>
		<li> type in parameters and select canonical units of CSG solids
		<li> add any number of nodes and facets of BREP solids and 
			type in their parameters and select canonical units 
		<li> preview with DAWN with automatically chosen world size
		<li> save DAWN format file of the solid
	
	</ul>
<hr>
      A code fragment of a logical volume "thintube" of
BREP PolyCone generated by MOMO. Words in red are those typed in by a user. 
<pre>
G4double DzArray<font color=red>thintube</font>   [] = 
     {-1000.0*micrometer, -750.0*micrometer, -500.0*micrometer, -250.0*micrometer, 
      0.0*micrometer, 250.0*micrometer, 500.0*micrometer, 750.0*micrometer, 
      1000.0*micrometer};
G4double RminArray<font color=red>thintube</font> [] = 
     {1.0*micrometer, 1.0*micrometer, 1.0*micrometer, 1.0*micrometer, 1.0*micrometer, 
      1.0*micrometer, 1.0*micrometer, 1.0*micrometer, 1.0*micrometer};
G4double RmaxArray<font color=red>thintube</font> [] = 
      {20.0*micrometer, 16.0*micrometer, 12.0*micrometer, 8.0*micrometer, 
       4.0*micrometer, 8.0*micrometer, 12.0*micrometer, 16.0*micrometer, 20.0*micrometer};

G4BREPSolidPCone *solid<font color=red>thintube</font> = new G4BREPSolidPCone("solidthintube",  //its name
0.0*mrad,  //its start angle
270.0*deg, //its opening angle
9,  //its nZ
DzArray<font color=red>thintube</font>[0],  //z start 
DzArray<font color=red>thintube</font>,  //z value 
RminArray<font color=red>thintube</font>,  //rmin 
RmaxArray<font color=red>thintube</font> );  //rmax

G4LogicalVolume * logical<font color=red>thintube</font> = new G4LogicalVolume(solid<font color=red>thintube</font>,  //its solid
<font color=red>carbon</font>,  //its material
"logical<font color=red>thintube</font>" , //its name
 0,0,0);

logical<font color=red>thintube</font>->SetVisAttributes(<font color=red>black</font>);
</pre>
<hr>  
 <li> <strong>Defining G4Color</strong><br>
   The visualization attribute and its name are required by the logical 
   volumes. They
   can be defined using a graphical color chooser.
	Each color's  given unique name is listed in the editor panel.
   The RGB numbers defined by the chooser are taken
		to generate C++ codes.
<br>
An example of code fragments generated by MOMO
<pre>
G4VisAttributes * lightblue= new G4VisAttributes( G4Colour(0/255. ,255/255. ,255/255. ));
</pre>

 <li><strong>"Make the used materials" </strong> button. <br>
	 Clicking this button, GGE scans the materials specified in the 
	 logical volume table and marks "in Use" cell (the first column ) 
	 of the material tables accordingly. All other materials not used in
   logical volumes are not marked.

	 Note that only rows marked "in Use" are used
		to generate C++ codes.
	     
</ol>
<hr>
</A><A HREF="#TOP">BACK</A><BR>
<A NAME="3-6">
<h2>3-6) The Physical Volume Editor</h2>

<BR>
The physical volume editor consists of five minor tables of different
way of displacement of a logical volume. Each table is contained in a tabbed pane.


<A NAME="3-6-1">
<h3>3-6-1) Limit of Physical volumes Editor</h3>
</A><br>
Compared with the logical volume editor, the physical volume one has limited
generality. So, if user aren't satisfied with the following simplistic ways
to place logical volumes, he can use partially generated C++ codes for
logical volumes etc. as a starting point.

<p>
<A NAME="3-6-2">
<h3>3-6-2) Constructors of G4PVPlacement</h3>
</A><A HREF="#TOP">BACK</A><br>
Following four types of constructor are implemented, 
according to the types of
rotation and types of the mother volume.
  <ol> 
  <li>	 Type 1 constructor = rotation of the frame, physical mother volume
  <li>	 Type 2 constructor = rotation of a body, physical mother volume
  <li>	 Type 3 constructor = rotation of the frame, logical mother volume
  <li>	 Type 4 constructor = rotation of a body, logical mother volume
  </ol>


Next are the example C++ codes generated by MOMO for the above four cases. In the first two cases,
words in red are those which user typed  in the cells of the editor. 
<OL>
<LI>"box-bp" and "box-fp" in the first column to specify the pName, i.e., the name of the unstance of G4PVPlacement 
<LI>"box" in the second column to spscify the names of their logical volumes, pLogical. All the names already defined in the logical volume panel are displayed to choose one. In this case, one "box" is used to make different physical volumes.
<LI>"container" in the pMother, i.e., name of the mother volume. The prefixes "logical" or "physical" are attached according to the type of the mother volume.
</OL> 

pNames are used as postfixes
to designate local variables like rotation matrices and rotation angles etc.. 
On the contrary, several prefixes are used to differentiate
instances, like physicalcontainer and logicalcontainer, where only "container" is typed in a cell.
<br>
Naming conventions will be explained later.

<hr>
<pre>

// Single Positioned Placement 
// <font color=green>Body rotation + physical mother</font>
G4RotationMatrix rotMatrix<font color=red>box-bp</font>;   // unit rotation matrix
G4double angle<font color=red>box-bp</font> = 0.0*deg;   // rotational angle
rotMatrix<font color=red>box-bp</font>.rotateX(angle<font color=red>box-bp</font>);  // rot matrix

G4VPhysicalVolume *  <font color=red>box-bp</font>= new G4PVPlacement(G4Transform3D(rotMatrix<font color=red>box-bp</font>,	//rotation 
		 G4ThreeVector(0.0*mm, 0.0*mm, 0.0*mm)),
		 "<font color=red>box-bp</font>",   //its name  (2nd constructor)
		 <font color=red>box</font>,         //its logical volume 
		 physical<font color=red>container</font>,              //its mother volume 
		 false,                 //no boolean operation 
		 0);                       //copy number 

// <font color=green>Frame rotation + physical mother</font>
G4RotationMatrix rotMatrix<font color=red>box-fp</font>;   // unit rotation matrix
G4double angle<font color=red>box-fp</font> = 0.0*deg;   // rotational angle
rotMatrix<font color=red>box-fp</font>.rotateX(angle<font color=red>box-fp</font>);  // rot matrix

G4VPhysicalVolume *  <font color=red>box-fp</font>= new G4PVPlacement( new G4RotationMatrix(rotMatrix<font color=red>box-fp</font>) ,        // Frame rotation 
		 G4ThreeVector(0.0*mm, 0.0*mm, 0.0*mm),
		 "<font color=red>box-fp</font>",   // 1st constructor its name 
		 <font color=red>box</font>,         //its logical volume 
		 physical<font color=red>container</font>,	//its mother volume 
		 false,	//no boolean operation 
		 0);	//copy number 

// <font color=green>Body rotation + logical mother</font>

G4RotationMatrix rotMatrixbox-bl;   // unit rotation matrix
G4double anglebox-bl = 0.0*deg;   // rotational angle
rotMatrixbox-bl.rotateX(anglebox-bl);  // rot matrix


G4VPhysicalVolume *  box-bl= new G4PVPlacement(G4Transform3D(rotMatrixbox-bl,	//rotation 
		 G4ThreeVector(0.0*mm, 0.0*mm, 0.0*mm)),
		 box,	//its current logical volume(4th constructor) 
		 "box-bl",    //its name 
		 logicalcontainer,              //its mother volume 
		 false,                 //no boolean operation 
		 0);                       //copy number 

// <font color=green>Frame rotation + logical mother</font>

G4RotationMatrix rotMatrixbox-fl;   // unit rotation matrix
G4double anglebox-fl = 0.0*deg;   // rotational angle
rotMatrixbox-fl.rotateX(anglebox-fl);  // rot matrix

G4VPhysicalVolume *  box-fl= new G4PVPlacement( new G4RotationMatrix(rotMatrixbox-fl) ,        // Frame rotation 
		 G4ThreeVector(0.0*mm, 0.0*mm, 0.0*mm),
		 box,	// 3rd constructor its logical volume 
		 "box-fl",    //its name 
		 logicalcontainer,	//its mother volume 
		 false,	//no boolean operation 
		 0);	//copy number 

</pre>
<hr>
Following simple placements are provided in GGE. Every placement is 
contained in independent tabbed pane.

<hr>
<A HREF="#TOP">BACK</A><BR>
<A NAME="3-6-3">
<h3>3-6-3)
Single Positioned Volume (SPV)</h3> </a><br>

 Each row represents a physical volume
 which has one-to-one
correspondence to a logical volume. The C++ code lines are demonstrated just above.<br>
<font color=red>IMPORTANT!!  The world volume must be
	defined in the first row of this table.</font>

  <ol>
   <li> The first column specifies either body or frame rotation.
   <li> The second column specifies the instance's name of the physical volume
   <li> The third column specifies the name of the logical volume to be placed
   <li> The fourth column specifies the type of the mother volume.
	The mother volume is either 
	null(Master Reference System), logical or physical. 
	The  MARS or the world volume must be specified at the first row.
   <li> The fifth column specifies the name of the mother volume, if it isn't NULL.
   <li> The columns 7, 8 and 9-th specify the translation  
	in the X, Y or Z direction (default is no translation) with a 
	selectable unit of length
   <li>The 11-th column specifies the axis of rotation  (frame or body); 
	 rotation around X, Y or Z axis with an angle in the 12-th column
   </ol>
<HR>
<A HREF="#TOP">BACK</A><BR>
<A NAME="3-6-4">
  <h3>3-6-4)
Repeated Translationally Positioned Volumes  (RTPV Arrangement)</h3></a><br>

 Each row represent a physical volume
 which consists	of any number of copies of a logical volume with incremental copy numbers.

  <ol>
  <li>The first to 4-th columns are same as above.  
   <li>The columns 6, 7 and 8-th specify the position of the first copy 
   <li> The 10-th column specifies the direction of placement; X, Y or Z direction
  <li> The 11-th column specifies the  incremental step size of displacement
  <li> The last column specifies the number of copies
  </ol>


Next is a fragment of C++ code generated from a line in the table. Here "Boses" is typed in the
first column, pName. This word is used as the postfix to designate local variables as well as
the loop variable. "box" is the pLogical, i.e., the name of the logical volume. Here the mother's
name is typed in as "world" in the pMother cell, and it is physical. The "box" logical volume
is translated  along X direction from X0 = -100*cm in 10*cm step with the copy numbers "copyBoxes" from 1 to 21.

<pre>
G4int copy<font color=red>Boxes</font>;
copy<font color=red>Boxes</font>=0;
for (G4int <font color=red>Boxes</font>=1; <font color=red>Boxes</font><=21; <font color=red>Boxes</font>++){
  G4double trans<font color=red>Boxes</font> =-100.0*cm+10.0*cm*(<font color=red>Boxes</font>-1);
  G4VPhysicalVolume * Boxes = new G4PVPlacement(0,      //no rotation 
		 G4ThreeVector(trans<font color=red>Boxes</font>, 0.0*cm, 0.0*cm),
		 "<font color=red>Boxes</font>",   //its name 
		 <font color=red>box</font>,         //its logical volume
		 physical<font color=red>world</font>,            //its mother volume
		 false,             //no boolean operation
		 copy<font color=red>Boxes</font>++);      //copy number 
}

</pre>


<HR>
<A HREF="#TOP">BACK</A><BR>
<A NAME="3-6-5">
<h3>3-6-5)  Repeated Rotationally Positioned Volumes;  (RRPV Arrangement)
</h3> </a><BR>

    Each row represents a physical volume
 which consists of 
 axially symmetric arrangement  of any number of copies of a
 logical volume with incremental copy numbers.<br>

  <ol>
  <li> The columns "move", "pName", "pLogic", "MomType" and "pMother" are same as above.

  <li>(X0, Y0, Z0) column specify the position of the center of an axial rotation
  <li>"Radius" column specifies a radius of axially symmetric arrangement
  <li>"RotAxis" column specifies the rotational axis ; X, Y or Z
  <li>"Phi_0" and "dPhi" column specify a starting angle and incremental step angle
  <li> The last column specifies the number of copies
  </ol>

A row of the table generates the C++ code lines as below. Here 
"Circle" is the pName.
The logical volume "box" is
copied around the Z axis from 0* deg with 30* deg step and with copy number "copyCircle" from 1 to 10.
The center of rotation (x0Circle, y0Circle, z0Circle) = (-200*mm, 100*mm, 0.0*mm).
<hr>
<pre>
// Active Rotation of Bodies
G4int copyCircle;
copyCircle=0;
G4RotationMatrix rotationMatrixCircle;G4double startCircle = 0.0*deg;
G4double incCircle = 30.0*deg;
rotationMatrixCircle.rotateZ(startCircle);
G4double x0Circle = -200.0*mm;
G4double y0Circle = 100.0*mm;
G4double z0Circle = 0.0*mm;
G4double radiusCircle = 300.0*mm;

for (G4int Circle=1; Circle<=10; Circle++){
  G4double transCircle = startCircle+incCircle*(Circle-1);

  G4double xCircle, yCircle, zCircle;
  xCircle = x0Circle + radiusCircle * cos(transCircle);
  yCircle = y0Circle + radiusCircle * sin(transCircle);
  zCircle = z0Circle;
  G4VPhysicalVolume * Circle = new G4PVPlacement(G4Transform3D(rotationMatrixCircle,	//rotate
		 G4ThreeVector(xCircle, yCircle, zCircle)),
		 "Circle",   //its name 
		 box,         //its logical volume
		 physicalworld,            //its mother volume
		 false,             //no boolean operation
		 copyCircle++);      //copy number 
  rotationMatrixCircle.rotateZ(incCircle);
}

</pre>

<HR>
</A><A HREF="#TOP">BACK</A><BR>
<A NAME="3-6-6">
  <h3> 3-6-6, 7) Replica in the X, Y or Z direction,
   Replica  in rho, phi or Z direction</h3>


<ol>
<li> width (in length or angle) and number of replicas
<li> offset (in length or angle)
<li> logical or physical mother volume
</ol>

Below is the C++ code lines generated from a row in the table. "Sliced" is the pName (the first column).
"box" is the logical volume to be sliced. pMother is "world" and it is the physical volume.
The number of replicas along X axis is 1000 with 2.0*micronmeter width and
with offset of -1.0*mm.
<hr>
<pre>
/ Slicing Translation 

G4PVReplica *  physicalSliced= new G4PVReplica("physicalSliced",  //name
		logicalbox,  // its logical
		physicalworld,  // its mother
		kXAxis, // along Axis
		1000, // No of replicas
		2.0*micrometer, //  width
		-1.0*mm); // offset

</pre>

Planned but 
not implemented yet are paremetrised volumes with  linear scaling or  linear rotation.

<hr>
<A HREF="#TOP">BACK</A><BR>
<A NAME="3-7">
<h2>
3-7) Generation of C++ code
</h2>
</A><BR>

GGE has two menu buttons to generate the implementation file and class definition file.

<ul>
<li>C++ code lines are written out to a editor widget and can be edited and saved to a file. 
	But edited file 
	loses the correspondence with the tables contents or the persistent file.
<li>The required and necessary header files are automatically included; elements, solid types etc.
<li>The order of creating instances is following; 
	<ol>
	<li> G4Elements, 
	<li> G4Material, 
	<li> G4VisAttributes, 
	<li> G4Solids, 
	<li> G4LogicalVolume,
	<li> Single Positioned Volumes, 
	<li> Repeated Volumes, 
	<li> Replicas
	<li> return the instance name of the MARS
	</ol>
  Order of instantiation inside each section is from the first row to downward.
</ul>

Here is a sample of automatically generated C++ code</a>
 which is created from completely skelton tables but with the class name "MyDetector".

<pre>
//***** Generated by Geant4 Geometry Editor at  Wed Feb 25 20:27:44 JST 2004 *****

//------HeaderFile-
 #include "MyDetector.hh"

#include "G4UnitsTable.hh"

#include "G4VUserDetectorConstruction.hh"

#include "globals.hh"
#include "G4Material.hh"
#include "G4MaterialTable.hh"
#include "G4Element.hh"
#include "G4ElementTable.hh"
#include "G4LogicalVolume.hh"
#include "G4ThreeVector.hh"
#include "G4PVPlacement.hh"
#include "G4PVReplica.hh"
#include "G4SDManager.hh"
#include "G4VisAttributes.hh"
#include "G4Colour.hh"

MyDetector::MyDetector()
{ ; }
MyDetector::~MyDetector()
{ ; }
G4VPhysicalVolume* MyDetector::Construct( )
{
// Elements

// Materials from Combination


// Materials from Scratch


// Visualization attributes


// Logical  Volumes


// Physical Volumes ----  Single Positioned Placement,   Repeated Placement,   Slicing  --------------------------- 


// Single Positioned Placement 


// Repeated Placement Translation 


// Repeated Placement AxialSymmetoric


// Slicing Translation 


// Slicing AxialSymmetric 


// return the physical World


</pre>
<hr>
Next is the definition file of this skelton class.
<hr>
<pre>

// Geometry Header File 
//   MyDetector.hh generated by Geant4 Geometry Editor at Wed Feb 25 20:27:44 JST 2004  


#ifndef MyDetector_h
#define  MyDetector_h  1

class G4VPhysicalVolume;
#include "G4VUserDetectorConstruction.hh"
class  MyDetector:  public G4VUserDetectorConstruction
   {      public:
      MyDetector();
     ~MyDetector();

      public:
      G4VPhysicalVolume* Construct();
  };
#endif

</pre>

<hr>
</A><A HREF="#TOP">BACK</A><br>
<A NAME="3-7-1">
<h3>
3-7-1) Naming conventions in GGE
</h3>
<BR>
 Knowing GGE's naming convention is helpful to read the generated C++ code as 
well as using GGE correctly. Look at relevant Geant4 constructors will be very
suggestive.

<ol>
 <li> Elements and materials
	<ol>
	<li> Elements are named "elementXXX", where XXX stands for the
		element's symbol in the periodic table.
	<li> materials are named just as you have typed in the second column
		of the material window.
	</ol>
  <li> solids and logical volumes<br>
	The "Name" typed in the first (leftmost) column of the "Logical Volume"
	is used to name the corresponding solid. If the name "world" is given
	to a logical volume of a Box, the G4Solid has an instance "solidworld".
   <li> logical and physical volumes<br>
	<ol>
	  <LI> The strings of the  pName (physical or logical) cells filled in the table are used literally as the names of instances. 
	<li><SPAN STYLE="text-decoration:line-through;">The instance of a physical volume defined by "pName" has
	  a name prefixed
	with "physical", i.,e., instance's name is "physical" + pName ( + =>
	string concatenation). "logical" is added to the instance of a logical
	volume.</SPAN>
	<li><SPAN STYLE="text-decoration:line-through;">In case of SPV (single positioned volume), the columns "pName" (instance of 
	physical volume) and "pLogical" may have the same strings.</SPAN>
	<li>
	<SPAN STYLE="text-decoration:line-through;">In case of RVA (repeated volumes arrangement), "pName" is different from 
	"pLogical" whose copies are repeatedly placed.</SPAN>
	</ol>
    <li>All variables are named after their proper instances.
	See for example, the control variable used in the for loop in the 
	RVA.
		<br>
	Another examples are arrays to define BREP geometry. 
</ol>
<hr>
</A><A HREF="#TOP">BACK</A><BR>
<A NAME="3-7-2">
<h3>
3-7-2) Default values and combo-boxes
</h3>

<ol>
<li> Default optional values of materials
	GGE provides default values in a pre-filled columns or with the
	combo-boxes. "Use", "State" and "Unit" columns are equipped with
	combo-boxes. Temperature and pressure column are pre-filled with
	273.15 * kelvin and 1 * atmosphere.
<li> Default values in volumes
	"Mother Type" is either NULL (mother of all), logical (type 2, 4 constructors)
	or physical (type 2 or 4 constructors) in G4PVPlacement.
</ol>

<hr>
<hr>
<A NAME="4">
<FONT color=#238e23 size=+3><B>
4)GPE: Geant4 Physics Editor</B></FONT>
</A><A HREF="#TOP">BACK</A><BR>
<HR>

GPE is the GUI tool for the user to be able to define the association 
between particles and processes.

It consists of two parts;
<DL>
<DT>Physics List Table
<DD>This is shown in the upper half of the GPE. Every row represents a
  C++ code line to add the doublet of a particle (the first column)
 and an EM process (the second column) with the default parameters (from the third through fifth column). The name of a particle  can be copied
from the table below by a mouse click.
<DT>EM particle table and EM process table
<DD>Two tables are displayed in tabbed panes, respectively. User select a particle(s) within the particle table and then click the "Append" button. A new row is created in the Physics List Table  with the default process "Null". Then,
user chooses a process and click the "Change process" button. 
</DL>


<HR>
</A><A HREF="#TOP">BACK</A><BR>
<A NAME="4-1">
<H3>4-1)Particle</h3>
<BR>

GPE helps the user to choose particles to be instantiated.

<ol>
<li>The user can either choose a set of all particles belonging to a category
or to choose an individual particle.
The following buttons are shown in the tabbed pane titled "EM Particles".
    <UL>
    <LI>one of either Bosons, Leptons, Mesons, Baryons, Ions
    <LI>all bosons, all leptons, all mesons, all baryons, all ions, all short-lived
    </UL>

Particles in the category "Shortlived" can be either chosen all at once
or not chosen at all. 
<li>
</ol>

<h3>
 C++ codes for particles instantiation
</h3>
<br>

GPE generates the
"ConstructParticle" method as follows; 
<pre>
void MyPhysicsList::ConstructParticle()
{
     ConstructBosons();
     ConstructLeptons();
     ConstructMesons();
     ConstructBarions();
     ConstructIons();
     ConstructShortLiveds();
}
</pre>

Then GPE generates codes for each category of particles,

<pre>
void MyPhysicsList::ConstructBosons()
{
     G4Geantino::GeantinoDefinition();
     ....
     ....    
}
</pre>


<HR>
</A><A HREF="#TOP">BACK</A><BR>
<A NAME="4-2"><h3>
4-2)EM Processes
</h3><BR>


With the GPE  the user can 
choose, associate and register a process to a particle.


Merits of GPE¡¡could be as follows;
<UL>
<LI> user can forget  many lengthy class names of particles and processes
<LI> user can forget to specify necessary class definition files
<LI> user can forget default values of stepping parameters associated to processes
<LI> user can forget how to register doublets of a particle and a process
<LI> it is quite easy to test a physics list
</UL>


<OL>
<LI>
Process Manager<BR>

    Information required to register a process to the process manager, i.e., 
    Pointer to the process object and ordering parameter for each DoIt 
<LI>
C++ code <BR>

From a row in the Physics List Table GPE generates C++ lines like;
<pre>
  G4Aprocess* aProcess;
  G4ParticleDefinition* particle;

  G4ProcessManager* pmanager = particle->GetProcessManager();
  if ( aProcess->IsApplicable(*particle) ) {
       pmanager->AddProcess(aProcess, idxAtRest, idxAlongStep, idxPostStep):
    }

</pre>

<LI>
On a selection of a process, the default (predefined) 
ordering parameters are given. The user can edit them as will.

<LI>
Available Processes
<UL>
Currently implemented in GPE are transportation,
electromagnetic and general (only G4Decay).
<LI>
The following electromagnetic processes are available in GPE;
 standard, muon, xray and lowenergy processes.
<LI>
Transportation and G4Decay are always included by GPE (default).
<LI>
Hadronic processes and models
 aren't implemented.
<LI>

Excluded processes are parametrization and optical, since both are deeply
correlated with the detector geometry.
</UL>
</OL>
<HR>
<A HREF="#TOP">BACK</A><BR>
<A NAME="4-3"><h3>4-3) C++ codes generated by GPE
</h3></A>

<OL>
<LI>C++ code for "ConstructProcess" method

<pre>
void MyPhysicsList::ConstructProcess()
{
     AddTransportation();
     ConstructEM();
     //ConstructHad();
     ConstructGeneral():
}

void ExN02PhysicsList::ConstructEM()
{
  theParticleIterator->reset();
  while( (*theParticleIterator)() ){
    G4ParticleDefinition* particle = theParticleIterator->value();
    G4ProcessManager* pmanager = particle->GetProcessManager();
    G4String particleName = particle->GetParticleName();

// Each if clause corresponds to a row in the PhysicsTable

    if (particleName == "gamma") {
      pmanager->AddProcess(new G4PhotoElectricEffect(),ordInActive,ordInActive,ordDefault);
    }
    if (particleName == "gamma") {
      pmanager->AddProcess(new G4ComptonScattering(),ordInActive,ordInActive,ordDefault);
    }
    if (particleName == "gamma") {
      pmanager->AddProcess(new G4GammaConversion(),ordInActive,ordInActive,ordDefault);
    }
    if (particleName == "gamma") {
      pmanager->AddProcess(new G4PolarizedComptonScattering(),ordInActive,ordInActive,ordDefault);
    }
    if (particleName == "e-") {
      pmanager->AddProcess(new G4MultipleScattering(),ordInActive,1,1);
    }
.....
.....
</pre>




<LI>
C++ code for ConstructGeneral()

<pre>
#include "G4Decay.hh"

void ExN02PhysicsList::ConstructGeneral()
{
  G4Decay* theDecayProcess = new G4Decay();
  theParticleIterator->reset();
  while( (*theParticleIterator)() ){
    G4ParticleDefinition* particle = theParticleIterator->value();
    G4ProcessManager* pmanager = particle->GetProcessManager();
    if (theDecayProcess->IsApplicable(*particle)) {
      pmanager ->AddProcess(theDecayProcess);
      pmanager ->SetProcessOrdering(theDecayProcess, idxPostStep);
      pmanager ->SetProcessOrdering(theDecayProcess, idxAtRest);
    }
  }
}

</pre>



<LI>GPE generates a header file of user's physics list class.
<LI>
C++ for default cut value can be generated, using user's cut length.
(no cut-by-region).
<pre>
void ExN02PhysicsList::SetCuts()
{
// defaultCutValue you have typed in is used

  if (verboseLevel >1){
    G4cout << "ExN02PhysicsList::SetCuts:";
  }
  SetCutsWithDefault();
}
</pre>
</OL>
<A HREF="#TOP">BACK</A><BR>
<A NAME="4-4">
<h3>4-4) Persistent file</H3></A>
<BR>
The class name and default cut value are indispensable to make C++ code or to
save to the persistent file. The contents of the GPE can be saved to a file
in the Java serialization format and can be reused.




<HR>
<A NAME="5">
<FONT color=#238e23 size=+3><B>
5)MOMO's Companion Files
</B></FONT>
</A>
<BR>
<HR>

The companion files are included under MomoHome.
The files in red are created by  MOMO.
<pre>
[~/MomoPlugin]$ ls -R MomoHome
MomoHome:
<font color=red>MomoN02Test.cc             PDGmaterials.xml</font>  include/
<font color=red>MomoN02MyDetector.g4dt</font>     README             src/
<font color=red>MomoN02PhysicsList.g4ph     Momomake.gmk    dicomVolume.xml</font>    vis.mac

MomoHome/include:
MomoEventAction.hh    <font color=red>MomoN02PhysicsList.hh</font>          MomoRunAction.hh
<font color=red>MomoN02MyDetector.hh</font>  MomoPrimaryGeneratorAction.hh  MomoVisManager.hh

MomoHome/src:
MomoEventAction.cc    <font color=red>MomoN02PhysicsList.cc</font>          MomoRunAction.cc
<font color=red>MomoN02MyDetector.cc</font>  MomoPrimaryGeneratorAction.cc  MomoVisManager.cc
</pre>
<A HREF="#TOP">BACK</A><BR>
<A NAME="5-1">
<h3>5-1)Momomake.gmk generated by MOMO</h3>
</A><BR>
Following is the automatically generated "Momomake.gmk" file. The word in red
is the target name specified by the user. In the example, 
G4WORKDIR and G4BINDIR (in orange) are specified in the relative path (period).
Note that the present directory means where momo was started.
<pre>
##### GNUmakefile #####
# ----------------------------------------------------------
# Script defining rules and paths for making binaries.
# ----------------------------------------------------------
# Automatic creation of GNUmakefile for Momo environment.
# with users selection of G4TARGET, UI and VIS variables
#  Momo is the name of legendary samurai who conquered bad geants. ----   H. Yoshida.

name := <font color=red>MomoN02Test</font>
G4TARGET := $(name)
G4EXLIB := true

# Vis/GUI used
G4VIS_USE_DAWN := 1
G4VIS_USE_DAWNFILE := 1
G4VIS_USE_OPENGLX := 1
G4VIS_USE_VRML := 1
G4VIS_USE_VRMLFILE := 1
# Vis/GUI built
G4VIS_BUILD_DAWN_DRIVER := 1
G4VIS_BUILD_DAWNFILE_DRIVER := 1
G4VIS_BUILD_OPENGLX_DRIVER := 1
G4VIS_BUILD_VRML_DRIVER := 1
G4VIS_BUILD_VRMLFILE_DRIVER := 1

# General Envs defined
G4SYSTEM:=Linux-g++
G4INSTALL:=/home/yoshidah/geant4.6.0.p01
<font color=orange>G4WORKDIR:=.
G4BINDIR:=./bin/Linux-g++</font>
G4USE_STL:=1
G4LIB_BUILD_STATIC:=1
G4LEDATA:=/home/yoshidah/G4DATA/G4EMLOW2.2
G4LEVELGAMMADATA:=/home/yoshidah/G4DATA/PhotonEvaporation

ifndef G4INSTALL
   G4INSTALL = ../../..
endif

.PHONY: all
all: lib bin

  include $(G4INSTALL)/config/binmake.gmk
</pre>

<HR>
<A NAME="5-2">
<h3>5-2)Main program generated by MOMO</h3>
</A><A HREF="#TOP">BACK</A><BR>
All the following codes are automatically generated by MOMO.
The red words are user defined class names, which MOMO uses for
code generation. The words in orange can be changed as will.
<pre>
//##### MOMO Main program #####
//# ----------------------------------------------------------
//# Automatic creation of the main program for Momo environment.
// 2003 December, updated for  geant4.6.0
// --------------------------------------------------------------
//   MomoN02Test.cc generated by Geant4 Momo
//     at Tue Feb 24 09:23:50 JST 2004  


// This code implementation is the intellectual property of
// the  GEANT4 collaboration.
//
// By copying, distributing or modifying the Program (or any work
// based on the Program) you indicate your acceptance of this statement,
// and all its terms.
//
// 
#include "G4RunManager.hh"
#include "G4UImanager.hh"
// Your choice of User Interface driver
#include "<font color=orange>G4UIGAG</font>.hh"
// Detector geometry generated by Momo's GGE
#include "<font color=red>MomoN02MyDetector</font>.hh"
// Physics List generated by Momo's GPE
#include "<font color=red>MomoN02PhysicsList</font>.hh"
// Momo's default PrimaryGeneratorAction
#include "MomoPrimaryGeneratorAction.hh"
#include "MomoRunAction.hh"
#include "MomoEventAction.hh"
#ifdef G4VIS_USE
#include "MomoVisManager.hh"
#endif
int main()
{
  // Construct the default run manager
  G4RunManager* runManager = new G4RunManager;
  // set mandatory initialization classes
  runManager->SetUserInitialization(new <font color=red>MomoN02MyDetector</font>);
  runManager->SetUserInitialization(new <font color=red>MomoN02PhysicsList</font>);
#ifdef G4VIS_USE
  // visualization manager
  G4VisManager* visManager = new MomoVisManager;
  visManager->Initialize();
#endif
  // set mandatory user action class
  runManager->SetUserAction(new MomoPrimaryGeneratorAction);
  // set user action classes to visualise trajectories
  runManager->SetUserAction(new MomoRunAction);
  runManager->SetUserAction(new MomoEventAction);
  // Initialize G4 kernel
  runManager->Initialize();
  // get the pointer to the User Interface manager 
  G4UImanager* UI = G4UImanager::GetUIpointer();
      G4UIsession * session = new <font color=orange>G4UIGAG</font>;
      session->SessionStart();
      delete session;
  // job termination
#ifdef G4VIS_USE
  delete visManager;
#endif
  delete runManager;
  return 0;
}


</pre>




<hr>
The following document is taken from the Geant4 documents to help
MOMO's Environment Panel.<BR>
<A NAME="10.5">
<FONT color=#238e23 size=+3><B>10.5 Makefiles and Environment 
Variables</B> </FONT>
</A><A HREF="#TOP">BACK</A>
<BR><BR>
<HR align=center SIZE=7>
<BR><BR><!-- ============================================== Section -->This 
section describes how the GNUmake infrastructure is implemented in Geant4 and 
provides a quick reference guide for the user/installer about the most important 
environment variables defined. 
<P>
<H2>10.5.1 The GNUmake system in Geant4</H2>As described in section 2.7.1.1 of 
this manual, the GNUmake process in Geant4 is mainly controlled by the following 
GNUmake script files (<KBD>*.gmk</KBD> scripts are placed in 
<KBD>$G4INSTALL/config</KBD>): 
<UL>
  <LI><KBD>architecture.gmk</KBD>: defining all the architecture specific 
  settings and paths. System settings are stored in 
  <KBD>$G4INSTALL/config/sys</KBD> in separate files. 
  <LI><KBD>common.gmk</KBD>: defining all general GNUmake rules for building 
  objects and libraries. 
  <LI><KBD>globlib.gmk</KBD>: defining all general GNUmake rules for building 
  compound libraries. 
  <LI><KBD>binmake.gmk</KBD>: defining the general GNUmake rules for building 
  executables. 
  <LI><KBD>GNUmake</KBD> scripts: placed inside each directory in the G4 
  distribution and defining directives specific to build a library (or a set of 
  sub-libraries) or and executable. </LI></UL>To build a single library (or a set 
of sub-libraries) or an executable, you must explicitly change your current 
directory to the one you're interested to and invoke the "<KBD>gmake</KBD>" 
command from there ("<KBD>gmake global</KBD>" for building a compound library). 
Here is a list of the basic commands or GNUmake "targets" one can invoke to 
build libraries and/or executables: 
<UL>
  <LI><KBD>gmake</KBD><BR>This will start the compilation process for building a 
  kernel library or a library associated to an example. Kernel libraries are 
  built with maximum granularity, i.e. if a category is a compound one, this 
  command will build all the related sub-libraries, _not_ the compound one. The 
  top level <KBD>GNUmakefile</KBD> in <KBD>$G4INSTALL/source</KBD> will also 
  build in this case a dependency map <KBD>libname.map</KBD> of each library to 
  establish the linking order automatically at the <KBD>bin</KBD> step. The map 
  will be placed in <KBD>$G4LIB/$G4SYSTEM</KBD>. 
  <LI><KBD>gmake global</KBD><BR>It will start the compilation process to build 
  a single compound kernel library per category. If issued sub-sequently to 
  "gmake", both installations 'granular' and 'compound' libraries will be 
  available (NOTE: will consistently increase the disk space required. Compound 
  libraries will then be selected by default at link time, unless 
  G4LIB_USE_GRANULAR is specified). 
  <LI><KBD>gmake bin</KBD> or <KBD>gmake</KBD> (only for examples/)<BR>It will 
  start the compilation process to build an executable. This command will build 
  implicitly the library associated to the example and link the final 
  application. It assumes _all_ kernel libraries are already generated and 
  placed in the correct <KBD>$G4INSTALL</KBD> path defined for them.<BR>The 
  linking order is controlled automatically in case libraries have been built 
  with maximum granularity, and the link list is generated on the fly. 
</LI></UL><B><KBD>lib/ bin/</KBD> and <KBD>tmp/</KBD> directories</B> 
<P>The <KBD>$G4INSTALL</KBD> environment variable specifies where the 
installation of the Geant4 toolkit should take place, therefore kernel libraries 
will be placed in <KBD>$G4INSTALL/lib</KBD>. The <KBD>$G4WORKDIR</KBD> 
environment variable is set by the user and specifies the path to the user 
working directory; temporary files (object-files and data products of the 
installation process of Geant4) will be placed in <KBD>$G4WORKDIR/tmp</KBD>, 
according to the system architecture used. Binaries will be placed in 
<KBD>$G4WORKDIR/bin</KBD>, according to the system architecture used. The path 
to <KBD>$G4WORKDIR/bin/$G4SYSTEM</KBD> should be added to <KBD>$PATH</KBD> in 
the user environment. 
<P><!-- ============================================== Section -->
<HR>

<H2>10.5.2 Environment variables</H2>Here is a list of the most important 
environment variables defined within the Geant4 GNUmake infrastructure, with a 
short explanation of their use. We recommend _not_ to override (explicitly or by 
accident) those environment variables listed here and marked with (!). 
<UL>
  <LI>System configuration 
  <P>$CLHEP_BASE_DIR<BR>Specifies the path where the CLHEP package is installed 
  in your system. 
  <P>$G4SYSTEM (!)<BR>Defines the architecture and compiler currently used. This 
  variable should be set automatically by the installer script "g4install" (in 
  case of installation of Geant4) or by the script "g4config" (in case of 
  pre-installed Geant4 and initial configuration of the user's environment). 
  <P></P>
  <LI>Installation paths 
  <P>$G4INSTALL<BR>Defines the path where the Geant4 toolkit should be 
  installed. It should be set by the system installer. By default, it sets to 
  $HOME/geant4, assuming the Geant4 distribution is placed in $HOME. 
  <P>$G4BASE (!)<BR>Defines the path to the source code. Internally used to 
  define $CPPFLAGS and $LDFLAGS for -I and -L directives. It has to be set to 
  $G4INSTALL/src. 
  <P>$G4WORKDIR<BR>Defines the path for the user's workdir for Geant4. It is set 
  by default to $HOME/geant4, assuming the user's working directory for Geant4 
  is placed in $HOME. 
  <P>$G4INCLUDE<BR>Defines the path where source header files may be mirrored at 
  installation by issuing <CODE>gmake includes</CODE> (default is set to 
  <CODE>$G4INSTALL/include</CODE>) 
  <P>$G4BIN, $G4BINDIR (!)<BR>Used by the system to specify the place where to 
  store executables. By default they're set to $G4WORKDIR/bin and 
  $G4BIN/$G4SYSTEM respectively. The path to $G4WORKDIR/bin/$G4SYSTEM should be 
  added to $PATH in the user environment. $G4BIN can be overridden. 
  <P>$G4TMP, $G4TMPDIR (!)<BR>Used by the system to specify the place where to 
  store temporary files products of the compilation/build of a user application 
  or test. By default they're set to $G4WORKDIR/tmp and $G4TMP/$G4SYSTEM 
  respectively. $G4TMP can be overridden. 
  <P>$G4LIB, $G4LIBDIR (!)<BR>Used by the system to specify the place where to 
  store libraries. By default they're set to $G4INSTALL/lib and $G4LIB/$G4SYSTEM 
  respectively. $G4LIB can be overridden. 
  <P></P>
  <LI>Build specific 
  <P>$G4TARGET<BR>Specifies the target (name of the source file defining the 
  main()) of the application/example to be built. This variable is set 
  automatically for the examples and tests placed in $G4INSTALL/examples. 
  <P>$G4EXEC_BUILD<BR>Flag specifying if to use a secondary template repository 
  or not for handling template instantiations at the time of building a user 
  application/example. For internal category tests in Geant4, this variable is 
  already in the related GNUmakefile. It's however not needed for examples and 
  tests in $G4INSTALL/examples, where class names are already mangled and 
  different each other. It applies only on those compilers which make use of 
  template repositories (see Appendix A.2 of this Guide). The secondary template 
  repository is set to $G4TREP/exec. 
  <P>$G4DEBUG<BR>Specifies to compile the code (libraries or examples) including 
  symbolic information in the object code for debugging. The size of the 
  generated object code can increase considerably. By default, code is compiled 
  in optimised mode ($G4OPTIMISE set). 
  <P>$G4NO_OPTIMISE<BR>Specifies to compile the code (libraries or examples) 
  without compiler optimisation. 
  <P>$G4NO_STD_NAMESPACE<BR>To avoid using the <I>std</I> namespace in the 
  Geant4 libraries. 
  <P>$G4NO_STD_EXCEPTIONS<BR>To avoid throwing of exceptions in Geant4. 
  <P>$G4_NO_VERBOSE<BR>Geant4 code is compiled by default in high verbosity mode 
  ($G4VERBOSE flag set). For better performance, verbosity code can be left out 
  by defining $G4_NO_VERBOSE. 
  <P>$G4LIB_BUILD_SHARED<BR>Flag specifying if to build kernel libraries as 
  shared libraries (libraries will be then used by default). If not set, static 
  archive libraries are built by default. 
  <P>$G4LIB_BUILD_STATIC<BR>Flag specifying if to build kernel libraries as 
  static archive libraries in addition to shared libraries (in case 
  $G4LIB_BUILD_SHARED is set as well). 
  <P>$G4LIB_USE_GRANULAR<BR>To force usage of "granular" libraries against 
  "compound" libraries at link time in case both have been installed. The Geant4 
  building system chooses "compound" libraries by default, if installed. 
  </P></LI></UL>
<UL>
  <LI>UI specific 
  <P>The most relevant flags for User Interface drivers are just listed here. A 
  more detailed description is given also in section 2. of this User's Guide. 
  <P>G4UI_USE_TERMINAL<BR>Specifies to use dumb terminal interface in the 
  application to be built (default). 
  <P>G4UI_BUILD_XM_SESSION, G4UI_BUILD_XAW_SESSION<BR>Specifies to include in 
  kernel library the <I>XM</I> or <I>XAW</I> Motif-based user interfaces. 
  <P>G4UI_USE_XM, G4UI_USE_XAW<BR>Specifies to use the <I>XM</I> or <I>XAW</I> 
  interfaces in the application to be built. 
  <P>G4UI_BUILD_WO_SESSION, G4UI_USE_WO<BR>Specifies to use the <I>WO</I> user 
  interface associated to the OPACS tool. 
  <P>G4UI_BUILD_WIN32_SESSION<BR>Specifies to include in kernel library the 
  WIN32 terminal interface for Windows systems. 
  <P>G4UI_USE_WIN32<BR>Specifies to use the WIN32 interfaces in the application 
  to be built on Windows systems. 
  <P>G4UI_NONE<BR>If set, no UI sessions nor any UI libraries are built. This 
  can be useful when running a pure batch job or in a user framework having its 
  own UI system. </P></LI></UL>
<UL>
  <LI>Visualization specific 
  <P>The most relevant flags for visualization graphics drivers are just listed 
  here. A description of these variables is given also in section 2. of this 
  User's Guide. 
  <P>$G4VIS_BUILD_OPENGLX_DRIVER<BR>Specifies to build kernel library for 
  visualization including the OpenGL driver with X11 extension. It requires 
  $OGLHOME set (path to OpenGL installation). 
  <P>$G4VIS_USE_OPENGLX<BR>Specifies to use OpenGL graphics with X11 extension 
  in the application to be built. 
  <P>$G4VIS_BUILD_OPENGLXM_DRIVER<BR>Specifies to build kernel library for 
  visualization including the OpenGL driver with XM extension. It requires 
  $OGLHOME set (path to OpenGL installation). 
  <P>$G4VIS_USE_OPENGLXM<BR>Specifies to use OpenGL graphics with XM extension 
  in the application to be built. 
  <P>$G4VIS_BUILD_OI_DRIVER<BR>Specifies to build kernel library for 
  visualization including the OpenInventor driver. It requires $OIHOME and 
  $HEPVISDIR set (paths to OpenInventor/HepVis installation). 
  <P>$G4VIS_USE_OI<BR>Specifies to use OpenInventor graphics in the application 
  to be built. 
  <P>$G4VIS_BUILD_OIX_DRIVER<BR>Specifies to build the driver for the free X11 
  version of OpenInventor. 
  <P>$G4VIS_USE_OIX<BR>Specifies to use the free X11 version of OpenInventor. 
  <P>$G4VIS_BUILD_OIWIN32_DRIVER<BR>Specifies to build the driver for the free 
  X11 version of OpenInventor on Windows systems. 
  <P>$G4VIS_USE_OIWIN32<BR>Specifies to use the free X11 version of OpenInventor 
  on Windows systems. 
  <P>$G4VIS_BUILD_OPACS_DRIVER<BR>Specifies to build kernel library for 
  visualization including the OPACS driver. It requires $OPACSHOME set (path to 
  OPACS installation). 
  <P>$G4VIS_USE_OPACS<BR>Specifies to use OpenInventor graphics in the 
  application to be built. 
  <P>$G4VIS_BUILD_DAWN_DRIVER<BR>Specifies to build kernel library for 
  visualization including the driver for DAWN. 
  <P>$G4VIS_USE_DAWN<BR>Specifies to use DAWN as a possible graphics renderer in 
  the application to be built. 
  <P>$G4DAWN_HOST_NAME<BR>To specify the hostname for use with the DAWN-network 
  driver. 
  <P>$G4VIS_NONE<BR>If specified, no visualization drivers will be built or 
  used. </P></LI></UL>
<UL>
  <LI>Analysis specific 
  <P>$G4ANALYSIS_USE<BR>Specifies to activate the appropriate environment for 
  analysis, if an application includes code for histogramming based on 
  <I>AIDA</I>. Additional setup variables are required 
  ($G4ANALYSIS_AIDA_CONFIG_CFLAGS, $G4ANALYSIS_AIDA_CONFIG_LIBS) to define 
  config options for AIDA ("aida-config --cflags" and "aida-config --libs"). See 
  installation instructions of the specific analysis tools for details. 
</P></LI></UL>
<UL>
  <LI>Directory paths to Physics Data 
  <P>$NeutronHPCrossSections<BR>Path to external data set for Neutron Scaterring 
  processes. 
  <P>$G4LEDATA<BR>Path to external data set for low energy electromagnetic 
  processes. 
  <P>$G4LEVELGAMMADATA<BR>Path to the data set for Photon Evaporation. 
  <P>$G4RADIOACTIVEDATA<BR>Path to the data set for Radiative Decay processes. 
  </P></LI></UL><!-- ============================================== Section -->
<HR>

<H2>10.5.3 Linking External Libraries with Geant4</H2>The Geant4 GNUmake 
infrastructure allows to extend the link list of libraries with external (or 
user defined) packages which may be required for some user's applications to 
generate the final executable. 
<P>
<H3>10.5.3.1 Adding external libraries which do *not* use Geant4</H3>In the 
<TT>GNUmakefile</TT> of your application, before including <TT>binmake.gmk</TT>, 
specify the extra library in <TT>EXTRALIBS</TT> either using the 
<TT>-L...-l...</TT> syntax or by specifying the full pathname, e.g.: <PRE>  EXTRALIBS := -L&lt;your-path&gt;/lib -l&lt;myExtraLib&gt;
or
  EXTRALIBS := &lt;your-path&gt;/lib/lib&lt;myExtraLib&gt;.a
</PRE>You may also specify <TT>EXTRA_LINK_DEPENDENCIES</TT>, which is added to 
the dependency of the target executable, and you may also specify a rule for 
making it, e.g.: <PRE>  EXTRA_LINK_DEPENDENCIES := &lt;your-path&gt;/lib/lib&lt;myExtraLib&gt;.a

  &lt;your-path&gt;/lib/lib&lt;myExtraLib&gt;.a:
        cd &lt;your-path&gt;/lib; $(MAKE)
</PRE>Note that you almost certainly need to augment <TT>CPPFLAGS</TT> for the 
header files of the external library, e.g.: <PRE>  CPPFLAGS+=-I&lt;your-path&gt;/include
</PRE>See table 10.5.1. 
<P>
<CENTER>
<TABLE cellPadding=8 border=1>
  <TBODY>
  <TR>
    <TD><PRE> # --------------------------------------------------------------------
 # GNUmakefile for the application "sim" depending on module "Xplotter"
 # --------------------------------------------------------------------

 name := sim
 G4TARGET := $(name)
 G4EXLIB := true

 CPPFLAGS  += -I$(HOME)/Xplotter/include
 EXTRALIBS += -L$(HOME)/Xplotter/lib -lXplotter
 EXTRA_LINK_DEPENDENCIES := $(HOME)/Xplotter/lib/libXplotter.a

 .PHONY: all

 all: lib bin

 include $(G4INSTALL)/config/binmake.gmk

 $(HOME)/Xplotter/lib/libXplotter.a:
         cd $(HOME)/Xplotter; $(MAKE)</PRE>
  <TR>
    <TD align=middle>Table 10.5.1<BR>An example of a customised GNUmakefile 
      for an application or example using an external module not bound to 
      Geant4. </TR></TBODY></TABLE></CENTER>
<P>
<H3>10.5.3.2 Adding external libraries which use Geant4</H3>In addition to the 
above, specify, in <TT>EXTRALIBSSOURCEDIRS</TT>, a list of directories 
containing source files in its <TT>src/</TT> subdirectory. Thus, your 
<TT>GNUmakefile</TT> might contain: <PRE>  EXTRALIBS += $(G4WORKDIR)/tmp/$(G4SYSTEM)/&lt;myApp&gt;/lib&lt;myApp&gt;.a \
               -L&lt;your-path&gt;/lib -l&lt;myExtraLib&gt;
  EXTRALIBSSOURCEDIRS += &lt;your-path&gt;/&lt;myApp&gt; &lt;your-path&gt;/&lt;MyExtraModule&gt;
  EXTRA_LINK_DEPENDENCIES := $(G4WORKDIR)/tmp/$(G4SYSTEM)/&lt;myApp&gt;/lib&lt;myApp&gt;.a

  MYSOURCES := $(wildcard &lt;your-path&gt;/&lt;myApp&gt;/src/*cc)
  $(G4WORKDIR)/tmp/$(G4SYSTEM)/&lt;myApp&gt;/lib&lt;myApp&gt;.a: $(MYSOURCES)
        cd &lt;your-path&gt;/&lt;myApp&gt;; $(MAKE)
</PRE>See Table 10.5.2. 
<P>
<CENTER>
<TABLE cellPadding=8 border=1>
  <TBODY>
  <TR>
    <TD><PRE># -----------------------------------------------------------------
# GNUmakefile for the application "phys" depending on module "reco"
# -----------------------------------------------------------------

name := phys
G4TARGET := $(name)
G4EXLIB := true

EXTRALIBS += $(G4WORKDIR)/tmp/$(G4SYSTEM)/$(name)/libphys.a \
             -L$(HOME)/reco/lib -lreco
EXTRALIBSSOURCEDIRS += $(HOME)/phys $(HOME)/reco
EXTRA_LINK_DEPENDENCIES := $(G4WORKDIR)/tmp/$(G4SYSTEM)/$(name)/libphys.a

.PHONY: all
all: lib bin

include $(G4INSTALL)/config/binmake.gmk

MYSOURCES := $(wildcard $(HOME)/phys/src/*cc)
$(G4WORKDIR)/tmp/$(G4SYSTEM)/$(name)/libphys.a: $(MYSOURCES)
	cd $(HOME)/phys; $(MAKE)</PRE>
  <TR>
    <TD align=middle>Table 10.5.2<BR>An example of a customised GNUmakefile 
      for an application or example using external modules bound to Geant4. 
  </TR></TBODY></TABLE></CENTER>
<P>
<HR>
<A NAME="7">
<FONT color=#238e23 size=+3><B>7. GAG and Gain</B> </FONT>

<BR><BR>
<HR align=center SIZE=7>


<A NAME="7-1">
<h2>7-1  How to use GAG</h2>
</A><A HREF="#TOP">BACK</A>
<BR>
Usage of GAG is simple.
<OL>
<LI>Click the GAG tab and open the GAG's pane
<LI>Click the top left Geant menu and its "Start" button
<LI>Choose the Geant4 binary file, using the file chooser and click on it
<LI>After a moment, the Geant4 command tree (at left) and parameter panel (at right) are displayed. AT the lower panel is displayed the outputs from Geant4 application. 
<LI>Click on the nodes or leaves make their help diaplayed. Commands in the opaque characters are inactive ones.
<LI>Parameters are either chosen from the list or typed in. 
<LI> Four buttons are available
  <UL>
  <li>"Default" button displays the default parameters of the command, if defined
  <li>"Current" button displays the current value(s), if available
  <li>"Clear" button clear the contents in the parameters cells
  <li>"Execute" button starts the command. During the execution, its color isn't in green.
  </UL>
<LI> Output from the Geant4 are shown in the lower window, if "Log_to_Terminal" button is cheched. This button can be unchecked at any time. "Log_to_File" button can be also cheched or unchecked at any time.
<LI>If you want to interrupt the execution, "Kill_Geant4" button is used.
</OL>
<A NAME="7-2">
<h2>7-2  How to use Gain</h2>
</A><A HREF="#TOP">BACK</A>

<hr>
<h3>What is Gain?</h3><p>
Gain(Geant4 adaptive interface for network) is a networked GUI tool based on GAG. 
It inherits almost all features of GAG and has new features to
make use of Geant4 running at (a) remote machine(s).
<p>
Gain runs on a client machine (Windows or Linux),
while Geant4 runs on a remote or local server (Linux or Solaris).
<p> 

It provides two ways to connect to the remote server; SSH mode and Gain socket mode. SSH mode is strongly recommended, since it is as safe as remote SSh
connection and it requires G4UIGAG as the Geant4's interface. 

<dl>
<dt> <strong>Gain SSH mode</strong>
<dl> Gain has a SSH client fuction and use it to connect to a remote server. Geant4 compiled with G4UIGAG class
     can be connected to Gain client. When a SSH connection is established after the authentication, 
     Gain displays the
     remote file browser with which user can choose a Geant4 executable and make it run.
     Data  are encrypted during their transfer and are decripted at both side. So, some CPU
     power is required for a client machine, if a large amount of data are transfered from
     the running Geant4 to Gain. <br> Output from the remote Geant4 are
     displayed on the Gain console.
      This console can be used as a normal
     SSH console and you can type in command directly.<br>
     Pluriel remote sessions can be accepted, each displayed in a separate 
     tabbed pane. A console is attached to each pane/session.
<dt> <strong>Gain socket mode</strong>
<dl> Gain uses its own way of connecting to a remote server. Remote Geant4 must be compiled with
G4UIGainServer class which is distributed in the standard Geant4 package. In this mode, user has to
make a Geant4 executable run on the remote server, after having logged in to the remote
machine. G4UIGainServer acts as a network server
and tells the number of port available for the Gain client. Gain client, after specifying the server and port
number, is allowed to connect to the Geant4. Geant4 output 
</dl>

<hr>
<h3>How to use Gain</h3>
<p>
The figure shows a scene when Gain is running in
Gain socket mode.
<p>
In this example, 
two tabbed panes are displayed to run remote Geant4s running on different servers.


<ol>
<li>
   Gain is started on the Cygwin console. Gain can be started with
   Java Web Start. 

<li>
   Top menu  to connect to a server or close (kill) the running G4ant4 or finish Gain.


<li> The window to
    choose SSh or Gain socket; now SSHINTERFACE is focused    

<li>After typing in the remote host name, 
   SSH login window is shown.

<li>
When SSH login is accepted, Gain shows the
  remore File Chooser. Geant4 with G4UIGAG interface can be started
from this chooser.   

<li> When Geant4 is started, 
        Geant4 initialisation output are shown on the cygwin console. 




<li> After the initialisation phase, 
 command tree window is available on Gain.   

<li> Then, the Gain console is shown below the command tree window.
See  the hardcopy
of the whole Gain window.
This console is the SSH console, so that you can type in Geant4 commands
in stead of selecting them in the above command panel.
<br>
You can shrink the console by single click on the triangle at the left
border.

<li> 
Two ways of ending Geant4 execution are provided.    
The command tree provides "exit" command which is just the "exit" of Geant4. On the top
menu, "Close one" menu is to send CTRL + C to the running Geant4 process. It can be sent at any
moment.

</ol>
<hr>
<h3>Notices on Gain console</h3><br>
<ul>
<li> At present, Gain's console displays ecerything G4cout from Geant4
with G4UIGAG interface. So, strings employed for Gain protocols are
displayed. Please ignore lines starting with @@.
<li> Gain console demands heavy Windows (X or Windows) power.
So, with old graphic accelerators like S3 etc. which are yet common
on Linux platforms, speed of console may be very slow. In such cases,
shrinking the console pane is a good way to speed up the execution.
<li> We have tested Gain over the Internet for a session of more than 24 hours.
On Windows XP, We observed some curious deformed tree icons during the session,
but the functions were correct and they became normal after some elapsed time.
<br>
Here is the copy of the long run.
<li> The console provides a session of G4UIterminal, and NOT G4UItcsh, at present.
<li>If you type "exit" on the console, the execution of Geant4 is stopped.
The console is yet a usual ssh console, while the upper windows for
the command tree is losing connection to Geant4. If you type in "exit" on the
console, it end the ssh session and the whole Gain will be destroyed.
</ul>
<hr>

<address>
<a href="mailto:yoshidah@naruto-u.ac.jp">yoshida</a>
</address>
</body>
</html>





<HR>
<A 
href="http://geant4.web.cern.ch/geant4/G4UsersDocuments/Authors/html/subjectsToAuthors.html"><I>About 
the authors</I></A>



<!----    *
      Download MOMO.taz and defreeze it
    *
      Detar it in $HOME/foo/MOMO
          o MOMO/src
                + MydetectorConstruction.cc, MyPhysicsList.cc 
          o MOMO/include
                + MyDetectorConstruction.hh, MyPhysicsList.hh 
          o MOMO/GNUmakefile
          o MOMO/myDetector.cc
          o Macro files for OGLIX and DAWN 
    *
      %make and you have a Geant4 binary in $G4INSTALL/bin/$G4SYATEM



4) A First Lesson; how to use GGE.

Here is a walk-through of how to use GGE.

4.1) Visualize the prefabricated detector sample
	1) In a xterm, type %java gge
	2) In the "Volume window", select "Load a Volume file" menu
		and double click on "trumpetBREP.g4dt"
	3) Click "Makesource" and select "Make C++ code". Have a look of the generated C++ code.
	4) Save the C++ code (overwrite the existing one)
		in .../GGEmake/src/MyDetectorConstruction.cc" using the file chooser.
	5) In another xterm, go to the directory GGEmake/ and type
		%make G4TARGET=myGGEdetector

		Watch if there is any compilation error. At present,
		GGE is made so that it generates correct C++ codes,
		if a user uses GGE correctly.

		In the example of "trumpetBREP.g4dt", a few warnings are shown on BREP.
	6) Check that you have "myGGEdetector" executable, in $(G4INSTALL)/bin/$(G4SYSTEM)
	7) In another xterm, type 
		%java gag
		
		and with the "Run GEANT4" button, choose and run "myGGEdetector".
        8) Use /control/execute command and double click on "GGEdraw.g4m".
		To have a better view, use vis~ commands (camera/viewpoint, zoom etc).
		You can select DAWNFILE to  draw and have a PS hardcopy.

4.2) Modify the prefabricated detector
 Now let's change the detector configuration. Go to the "Volume" window
	and change any part of it, including material.

4.2.1) Changing materials
		
	1) First, you have to  "Clear Material" in the Material editor. 
	2) Then, select "Load material" and double click on "MaterialDB.g4mt". 
		    Now you have a list of materials.
	3) Then, in the "Logical Volume" panel, double click the box you want to change
		    and type in the name of the material in the material editor.
	4) Change as many materials as you like and push "Used Material" button.
		    You see that materials you have typed in are marked "Used" in red.
		    If not, you might have mistyped the name of a material.
	5) If you want to use additional materials, select  "Use" in the material 
		   editor (the leftmost column).
	6) Push "Makesource" and see your change has been realized in the C++ code.

	NOTE!! Be careful that there are no duplicated "Used" materials, when
		you load the material DB without "Clear Material".

4.2.2) Modifying the size parameters of solids

	To change the sizes of G4 solids
	1) click a "solid" box of the logical volume of your choice. 
	2) You have a pop-up window to edit the parameters. Change a parameter 
			or its unit, as you like.
	3) Push "Makesource" and see if your changes have been correctly applied 
			to C++ code.
	4) In case of BREP solids, the pop-up window has variable number of columns
			to accept any number of nodes.
	5) For complicated solids like BREPs, preview may be useful. Click "View"
			button and you have a view with the DAWN renderer. Its g4.prim file
			is also shown in an edit-able widget.

4.2.3) Changing the type of solid of an existing logical volume
   You may want to replace the current G4Solid with another one. In the 
    present GGE you can't do so directly. You have to "Create" a new logical
    volume with the type of solid you want and then delete the unnecessary volume.

	1) Choose your new solid with "Select Solid" combo-box.
	2) Push "Create" button and you have a pop-up window to input parameters.
	3) Type in numbers and select their units.  
	4) Preview if you like and then push "OK".
	5) Check the C++ code.

4.2.4) Changing visualization attributes (Color).
	1) You have to "Create" a new VisAttributes
	2) Upon the "Create" button, you have a Color Chooser.
	3) Select RGB (not HSV). Set your color with slide-bars.
	4) Give it a name, and push "OK". Then you have a color circle and name in the
		VisAttrib panel.
	5) Edit the VisAtb box in the LogicalVolume panel.
	6) See the C++ code.

4.2.5) Changing Repeated Volumes




"exampleN01.g4dt" contains three "single positioned volumes"
		and one "repeated volumes" in the X direction.
		Change the parameter of repetition such as the number
		or width, or you can add another "repeated volumes"
		in another direction.

		In "trumpetBREP.g4dt" you can edit BREPs, adding new faces etc..

	   b) making C++ code "MyDetectorConstruction.cc" and compile.

		Finally, back to the step 3 and recompile.


	Opening GGE, compile, GAG simultaneously, you can 
	test and improve the geometry, just like creating
	HTML or TeX documents.


 2.4) GGEmake; a directory containing the GEANT4 codes to compile and visualize the detector
     a) implemented
	+ GNUmakefile
	+ myDetector.cc ; main()  with GAG session and visualization manager
	+ src/ directory contains
		+ MyDetectorConstruction.cc
                + MyPhysicsList.cc
		+ MyPrimaryGeneratorAction.cc
		+ MyVisManager.cc
	+ include/ directory

 2.5) compile and visualize with Momo and GAG

    a) implemented

	+ canonical scheme of GEANT4 to compile
	   	+ make G4TARGET=myDetector
		+ the binary is created as $G4INSTALL/bin/G4SYSTEM/myDetector

	+ Momo (GAG, Compile and GGE buttons)
		+ rapid cycling of GGE and GAG to edit and view the geometry
		+ a macro file for visualization (OGLIX default) "DrawDAWN.g4m", etc..

     b) not implemented
		- automatic "calibration" of the detector with geantino

 2.6) exemplary persistent detector files with *.g4dt suffix 
	 + 3D array of lead plates using translational RVArrangement
	 + BREP Pcones trumpetss  using axially symmetric RVArrangement
	 + Replicas to form  cylinders

-------------------------------------------------------------------------
</pre>
</font>
<hr>
<hr>
<hr>

<font color=red> !!!!!OBSOLETE!!!!!

<p>

<pre>
3) Installation

The minimum set to get C++ source code
	1) GGE.jar file
	2) Java interpreter ; java
Additional set to compile
	3) GEANT4 toolkit with compiled libraries
	4) GGEmake directory
Additional set to visualise and use GUI
	4) DAWN (plus Ghostview) or OGLIX or VRML
	5) GAG (Java version) or GAG.jar file
Additional too to make life easy
	6) Momo to use all the above ingredients; Momo.jar file
	 (without Momo, you have to invoke GGE, compile and GAG respectively in windows.)

3.1) Java and Swing
We have tested GGE on Unix-en (Linux and Solaris) and Windows (95/NT).

 3.1.1) Unix:

  + Linux: jdk1.1.3 or later(i.,e., jdk-1.1.6) + Swing-1.0.2
	1) jdk1.1.5 may have bugs, while jdk1.1.6 works
	2) GGE co-works with Swing-1.0.2 and not with 1.0.1 (or maybe not
		with 1.0.3).
	3) we are testing the current GGE with JRE1.2-beta04. The present source can be
		compiled but doesn't execute correctly. In any case
		Sun has announced on 17 August that JDK1.2 will be delayed
		till November!!
  + Solaris: jdk1.1.6 + swing-1.0.2


  We assume that you have 
	1)jdk1.1.6/bin/java (Java interpreter)  to which paths are set
	2)Swing-1.0.2 which is defreezed and placed in $HOME/swing/swingall.jar

 3.1.2) Windows:

	We use JBuilder2 with  Swing-1.0.2. Note that you have to 
	eliminate all other libraries than swing-1.0.2, after having
	copied it into JBuilder2.

	We are trying JDK1.2beta4 + JRE1.2 with JBuilder2.

	NOTE! At present we have not Momo/GAG for Windows. So,
	you can only create C++ code under the Windows.

3.2) GGE and related files
The latest product of GGE is that of Sep. 24.
All *.java, *.class and GGE.jar files are placed in 
		geant4beta/environments/Momo/java/Momo/GGE

Only "GGE.jar" file is necessary to run GGE. 

	GGE/*.java	GGE source files
	GGE/*.class	GGE byte code files
	GGE/GGE.jar	jar archive file to which CLASSPATH must be set
	GGE/*.g4mt	material database after PDG data
	GGE/*.g4dt	exampleN0x detector file
C++ source codes and GNUmakefiles to compile with GEANT4 are placed in
       		geant4beta/environments/Momo/GGEmake.

Only geantino is instantiated in the initialization of GEANT4, so that it is quite
rapid to have a visualization of the geometry. You can choose DAWN, OpenGL or VRML system.

	 GGEmake/myGGEdetector.cc		main() program
		/GNUmakefile
		/src
		/src/MyDetectorConstruction.cc	C++ generated by GGE
 		/src/MyPrimaryGeneratorAction.cc	geantino gun
		/src/MyVisManager.cc		DAWN, DAWNFILE, OGLIX, OGLSX, VRML1, VRML1FILE
		/src/MyPhysicsList.cc		geantino definition
		/include/*.hh
		/GGEdraw.g4m			default macro file to visualize with OGLIX

3.3) install, setenv and run

	%set path=($path jdk1.1.6/bin)  	<=== add the path to java and javac
	%setenv CLASSPATH .:$HOME/swing/swingall.jar:$HOME/geant4beta/environments/Momo/java/Momo/GGE/GGE.jar


  Then in any directory, you can invoke GGE.

	%java gge


3.4) DAWN, Tcl/Tk and Postscript for the preview of CSG or BREP solids
 If you don't use GGE's preview button, these are not necessary.

 If you want to  preview  G4Solids, you have to install
DAWN, Fukui renderer as well as Tcl/Tk wish (Tcl/Tk 8.0) for its GUI. 
DAWN uses also Postscript to draw *.prim files.  

For the visualization of the whole detector, DAWN or  Mesa (for OGLIX)
are necessary.

3.5) GEANT4 toolkit and its environments
The visualization manager instantiates DAWN, DAWNFILE, OPENGLIX,
OPENGLSX, VRML, VRMLFILE. So, you have to setenv accordingly.


</pre>
</font>

---->

</body>
</html>








